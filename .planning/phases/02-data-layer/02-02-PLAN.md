---
phase: 02-data-layer
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/lib/sync/queue.ts
  - src/lib/sync/engine.svelte.ts
  - src/lib/sync/status.svelte.ts
  - src/convex/chores.ts
  - src/convex/schema.ts
autonomous: true

must_haves:
  truths:
    - "Mutations made offline are queued in IndexedDB"
    - "Queued mutations sync to Convex when connectivity returns"
    - "Sync failures increment retry count and mark as failed after 3 attempts"
    - "Online/offline status is tracked reactively"
  artifacts:
    - path: "src/lib/sync/queue.ts"
      provides: "Mutation queue operations"
      exports: ["enqueueMutation", "getPendingMutations", "removeMutation", "incrementRetry", "markFailed"]
    - path: "src/lib/sync/engine.svelte.ts"
      provides: "Sync orchestrator with Convex integration"
      exports: ["syncEngine"]
    - path: "src/lib/sync/status.svelte.ts"
      provides: "Reactive connection status"
      exports: ["connectionStatus"]
    - path: "src/convex/chores.ts"
      provides: "Convex mutations for sync"
      exports: ["create", "update", "remove", "list"]
  key_links:
    - from: "src/lib/sync/engine.svelte.ts"
      to: "src/lib/sync/queue.ts"
      via: "getPendingMutations call"
      pattern: "getPendingMutations\\(\\)"
    - from: "src/lib/sync/engine.svelte.ts"
      to: "convex"
      via: "Convex mutation calls"
      pattern: "useMutation|api\\.chores"
    - from: "src/lib/sync/queue.ts"
      to: "src/lib/db/client.ts"
      via: "getDB for IndexedDB access"
      pattern: "getDB\\(\\)"
---

<objective>
Create sync engine that queues offline mutations and syncs to Convex when online.

Purpose: Enable true offline-first behavior where users can complete actions without connectivity, with automatic background sync when connection is restored.

Output: Complete sync infrastructure with mutation queue, sync engine, and Convex mutations for the chore domain.
</objective>

<execution_context>
@/Users/mike.wojnarowski/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike.wojnarowski/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-data-layer/02-RESEARCH.md

# From Plan 01 (dependency)
@src/lib/db/schema.ts (MutationSchema, STORES)
@src/lib/db/client.ts (getDB)
@src/lib/db/operations.ts (putChore, getChore)

# Existing Convex setup
@src/convex/schema.ts (current schema, needs expansion)
@src/routes/+layout.svelte (Convex client setup pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create mutation queue and connection status</name>
  <files>src/lib/sync/queue.ts, src/lib/sync/status.svelte.ts</files>
  <action>
Create the sync directory with queue management and connection tracking:

**src/lib/sync/queue.ts:**
```typescript
import { getDB } from '$lib/db/client';
import { STORES, MutationSchema, type Mutation } from '$lib/db/schema';

export async function enqueueMutation(
  type: Mutation['type'],
  table: string,
  payload: Record<string, unknown>
): Promise<string> {
  const db = await getDB();
  const mutation: Mutation = {
    id: crypto.randomUUID(),
    type,
    table,
    payload,
    createdAt: Date.now(),
    retryCount: 0,
  };

  // Validate before storing
  MutationSchema.parse(mutation);
  await db.add(STORES.mutationQueue, mutation);
  return mutation.id;
}

export async function getPendingMutations(): Promise<Mutation[]> {
  const db = await getDB();
  return db.getAllFromIndex(STORES.mutationQueue, 'by-created-at');
}

export async function getMutation(id: string): Promise<Mutation | undefined> {
  const db = await getDB();
  return db.get(STORES.mutationQueue, id);
}

export async function removeMutation(id: string): Promise<void> {
  const db = await getDB();
  await db.delete(STORES.mutationQueue, id);
}

export async function incrementRetry(id: string): Promise<number> {
  const db = await getDB();
  const tx = db.transaction(STORES.mutationQueue, 'readwrite');
  const mutation = await tx.store.get(id);
  if (mutation) {
    mutation.retryCount += 1;
    await tx.store.put(mutation);
    await tx.done;
    return mutation.retryCount;
  }
  await tx.done;
  return 0;
}

export async function markFailed(id: string): Promise<void> {
  // For now, we keep failed mutations in queue for manual retry
  // Could move to a separate 'failedMutations' store if needed
  const db = await getDB();
  const mutation = await db.get(STORES.mutationQueue, id);
  if (mutation) {
    // Update payload to mark as failed
    mutation.payload = { ...mutation.payload, _failed: true, _failedAt: Date.now() };
    await db.put(STORES.mutationQueue, mutation);
  }
}

export async function getQueueLength(): Promise<number> {
  const db = await getDB();
  return db.count(STORES.mutationQueue);
}

export async function clearQueue(): Promise<void> {
  const db = await getDB();
  await db.clear(STORES.mutationQueue);
}
```

**src/lib/sync/status.svelte.ts:**
```typescript
import { browser } from '$app/environment';

class ConnectionStatus {
  isOnline = $state(browser ? navigator.onLine : true);
  lastOnlineAt = $state<number | null>(browser && navigator.onLine ? Date.now() : null);

  constructor() {
    if (browser) {
      window.addEventListener('online', this.handleOnline);
      window.addEventListener('offline', this.handleOffline);
      // Also track visibility for sync triggers
      document.addEventListener('visibilitychange', this.handleVisibility);
    }
  }

  private handleOnline = () => {
    this.isOnline = true;
    this.lastOnlineAt = Date.now();
  };

  private handleOffline = () => {
    this.isOnline = false;
  };

  private handleVisibility = () => {
    // Trigger sync check when tab becomes visible
    if (document.visibilityState === 'visible' && this.isOnline) {
      this.lastOnlineAt = Date.now(); // Force reactivity update
    }
  };

  destroy() {
    if (browser) {
      window.removeEventListener('online', this.handleOnline);
      window.removeEventListener('offline', this.handleOffline);
      document.removeEventListener('visibilitychange', this.handleVisibility);
    }
  }
}

export const connectionStatus = new ConnectionStatus();
```

Key patterns:
- MutationSchema validates queue entries
- Mutations stored with timestamp for ordering
- retryCount tracks failed attempts
- markFailed keeps mutation for potential manual retry
- visibilitychange triggers sync when user returns to tab
  </action>
  <verify>
- `bun run check` passes
- Both files export correctly
- No circular imports with db module
  </verify>
  <done>Mutation queue and connection status tracking implemented</done>
</task>

<task type="auto">
  <name>Task 2: Expand Convex schema and add chore mutations</name>
  <files>src/convex/schema.ts, src/convex/chores.ts</files>
  <action>
Update Convex schema and add mutations for sync engine to call:

**src/convex/schema.ts** (replace existing):
```typescript
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  // Chores table - main entity for farm chore tracking
  chores: defineTable({
    clientId: v.string(), // Client-generated UUID for offline-first idempotency
    text: v.string(),
    isCompleted: v.boolean(),
    completedAt: v.optional(v.string()),
    completedBy: v.optional(v.string()),
    lastModified: v.number(),
  })
    .index("by_last_modified", ["lastModified"])
    .index("by_client_id", ["clientId"]),

  // Keep tasks for backwards compatibility during transition
  tasks: defineTable({
    text: v.string(),
    isCompleted: v.boolean(),
  }),
});
```

**src/convex/chores.ts** (new file):
```typescript
import { v } from "convex/values";
import { mutation, query } from "./_generated/server";

// Query: Get all chores
export const list = query({
  args: {},
  handler: async (ctx) => {
    return await ctx.db.query("chores").collect();
  },
});

// Query: Get chores modified since timestamp (for delta sync)
export const listSince = query({
  args: { since: v.number() },
  handler: async (ctx, { since }) => {
    return await ctx.db
      .query("chores")
      .withIndex("by_last_modified", (q) => q.gt("lastModified", since))
      .collect();
  },
});

// Mutation: Create chore
export const create = mutation({
  args: {
    clientId: v.string(), // Client-generated UUID for offline-first idempotency
    text: v.string(),
    isCompleted: v.boolean(),
    completedAt: v.optional(v.string()),
    completedBy: v.optional(v.string()),
    lastModified: v.number(),
  },
  handler: async (ctx, args) => {
    // Check if already exists (idempotent for retry safety)
    const existing = await ctx.db
      .query("chores")
      .withIndex("by_client_id", (q) => q.eq("clientId", args.clientId))
      .first();

    if (existing) {
      // Already synced, return existing
      return existing._id;
    }

    return await ctx.db.insert("chores", {
      clientId: args.clientId,
      text: args.text,
      isCompleted: args.isCompleted,
      completedAt: args.completedAt,
      completedBy: args.completedBy,
      lastModified: args.lastModified,
    });
  },
});

// Mutation: Update chore
export const update = mutation({
  args: {
    id: v.id("chores"),
    text: v.optional(v.string()),
    isCompleted: v.optional(v.boolean()),
    completedAt: v.optional(v.string()),
    completedBy: v.optional(v.string()),
    lastModified: v.number(),
  },
  handler: async (ctx, { id, lastModified, ...updates }) => {
    const existing = await ctx.db.get(id);
    if (!existing) {
      throw new Error(`Chore ${id} not found`);
    }

    // Last-write-wins: only apply if newer
    if (lastModified > existing.lastModified) {
      await ctx.db.patch(id, { ...updates, lastModified });
    }

    return id;
  },
});

// Mutation: Delete chore
export const remove = mutation({
  args: { id: v.id("chores") },
  handler: async (ctx, { id }) => {
    const existing = await ctx.db.get(id);
    if (existing) {
      await ctx.db.delete(id);
    }
    // Idempotent: no error if already deleted
    return id;
  },
});
```

After editing, push to Convex:
```bash
bunx convex dev --once
```

Key patterns:
- clientId (client-generated UUID) stored in Convex for idempotent creates
- Index on clientId enables efficient lookup for retry safety
- Idempotent mutations (safe to retry)
- Last-write-wins conflict resolution via lastModified
- Index on lastModified for delta sync queries
  </action>
  <verify>
- `bunx convex dev --once` succeeds and deploys
- New chores table appears in Convex dashboard
- Generated types in src/convex/_generated/api.d.ts include chores
- `bun run check` passes
  </verify>
  <done>Convex schema expanded with chores table and CRUD mutations</done>
</task>

<task type="auto">
  <name>Task 3: Create sync engine with Convex integration</name>
  <files>src/lib/sync/engine.svelte.ts</files>
  <action>
Create the main sync engine that orchestrates mutation processing:

**src/lib/sync/engine.svelte.ts:**
```typescript
import { browser } from '$app/environment';
import { getConvexClient } from 'convex-svelte';
import { api } from '../../convex/_generated/api';
import { connectionStatus } from './status.svelte';
import {
  getPendingMutations,
  removeMutation,
  incrementRetry,
  markFailed,
  getQueueLength,
} from './queue';
import { putChore, getChoresByStatus } from '$lib/db/operations';
import type { Mutation, Chore } from '$lib/db/schema';

const MAX_RETRIES = 3;
const SYNC_INTERVAL_MS = 30_000; // 30 seconds when online and visible

class SyncEngine {
  isSyncing = $state(false);
  pendingCount = $state(0);
  failedCount = $state(0);
  lastSyncedAt = $state<number | null>(null);
  lastError = $state<string | null>(null);

  private syncIntervalId: ReturnType<typeof setInterval> | null = null;
  private initialized = false;

  async init() {
    if (!browser || this.initialized) return;
    this.initialized = true;

    // Initial count
    this.pendingCount = await getQueueLength();
    this.failedCount = (await getChoresByStatus('failed')).length;

    // Process queue if we start online
    if (connectionStatus.isOnline) {
      await this.processQueue();
    }

    // Set up periodic sync when online
    this.startPeriodicSync();

    // React to online status changes
    $effect.root(() => {
      $effect(() => {
        if (connectionStatus.isOnline && connectionStatus.lastOnlineAt) {
          // Came online or visibility changed - trigger sync
          this.processQueue();
        }
      });
    });
  }

  private startPeriodicSync() {
    if (this.syncIntervalId) return;

    this.syncIntervalId = setInterval(() => {
      if (connectionStatus.isOnline && document.visibilityState === 'visible') {
        this.processQueue();
      }
    }, SYNC_INTERVAL_MS);
  }

  async processQueue() {
    if (this.isSyncing || !connectionStatus.isOnline) return;

    this.isSyncing = true;
    this.lastError = null;

    try {
      const mutations = await getPendingMutations();
      this.pendingCount = mutations.length;

      for (const mutation of mutations) {
        // Skip already-failed mutations
        if (mutation.payload._failed) continue;

        try {
          await this.applyMutation(mutation);
          await removeMutation(mutation.id);
          this.pendingCount = Math.max(0, this.pendingCount - 1);
        } catch (error) {
          const retryCount = await incrementRetry(mutation.id);
          if (retryCount >= MAX_RETRIES) {
            await markFailed(mutation.id);
            this.failedCount += 1;
            console.error(`[Sync] Mutation ${mutation.id} failed after ${MAX_RETRIES} retries`, error);
          } else {
            console.warn(`[Sync] Mutation ${mutation.id} failed, retry ${retryCount}/${MAX_RETRIES}`, error);
          }
        }
      }

      this.lastSyncedAt = Date.now();
    } catch (error) {
      this.lastError = error instanceof Error ? error.message : 'Sync failed';
      console.error('[Sync] Queue processing error:', error);
    } finally {
      this.isSyncing = false;
    }
  }

  private async applyMutation(mutation: Mutation): Promise<void> {
    const client = getConvexClient();
    if (!client) {
      throw new Error('Convex client not available');
    }

    const { type, table, payload } = mutation;

    if (table !== 'chores') {
      throw new Error(`Unknown table: ${table}`);
    }

    switch (type) {
      case 'create':
        await client.mutation(api.chores.create, payload as {
          clientId: string;
          text: string;
          isCompleted: boolean;
          completedAt?: string;
          completedBy?: string;
          lastModified: number;
        });
        // Update local record to synced
        await this.markLocalSynced(payload.clientId as string);
        break;

      case 'update':
        await client.mutation(api.chores.update, payload as {
          id: string;
          text?: string;
          isCompleted?: boolean;
          completedAt?: string;
          completedBy?: string;
          lastModified: number;
        });
        await this.markLocalSynced(payload.id as string);
        break;

      case 'delete':
        await client.mutation(api.chores.remove, { id: payload.id } as { id: string });
        break;

      default:
        throw new Error(`Unknown mutation type: ${type}`);
    }
  }

  private async markLocalSynced(id: string): Promise<void> {
    const { getChore, putChore } = await import('$lib/db/operations');
    const chore = await getChore(id);
    if (chore) {
      await putChore({ ...chore, syncStatus: 'synced' });
    }
  }

  async retryFailed(): Promise<number> {
    // Reset failed mutations for retry
    const mutations = await getPendingMutations();
    let resetCount = 0;

    for (const mutation of mutations) {
      if (mutation.payload._failed) {
        mutation.retryCount = 0;
        delete mutation.payload._failed;
        delete mutation.payload._failedAt;
        // Re-enqueue (put will update existing)
        const db = (await import('$lib/db/client')).getDB();
        await (await db).put('mutationQueue', mutation);
        resetCount += 1;
      }
    }

    this.failedCount = 0;
    await this.processQueue();
    return resetCount;
  }

  destroy() {
    if (this.syncIntervalId) {
      clearInterval(this.syncIntervalId);
      this.syncIntervalId = null;
    }
    this.initialized = false;
  }
}

export const syncEngine = new SyncEngine();
```

Key patterns:
- Singleton sync engine with reactive state via $state
- processQueue is idempotent (safe to call multiple times)
- Exponential backoff implicit in retryCount tracking
- $effect.root for reactive online status handling
- retryFailed allows manual retry of stuck mutations
- 30-second periodic sync when online and visible
  </action>
  <verify>
- `bun run check` passes
- File exports syncEngine singleton
- No TypeScript errors with Convex API types
- getConvexClient import resolves from convex-svelte
  </verify>
  <done>Sync engine created with queue processing, Convex integration, and failure handling</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **TypeScript check:**
   ```bash
   bun run check
   ```
   Expected: 0 errors

2. **Convex deployment:**
   ```bash
   bunx convex dev --once
   ```
   Expected: Successful push with chores table

3. **Build:**
   ```bash
   bun run build
   ```
   Expected: Build succeeds

4. **File structure:**
   ```
   src/lib/sync/
   ├── queue.ts          (mutation queue CRUD)
   ├── status.svelte.ts  (reactive online status)
   └── engine.svelte.ts  (sync orchestrator)

   src/convex/
   ├── schema.ts         (expanded with chores)
   └── chores.ts         (CRUD mutations)
   ```

5. **Convex functions exist:**
   Check `src/convex/_generated/api.d.ts` includes:
   - api.chores.list
   - api.chores.listSince
   - api.chores.create
   - api.chores.update
   - api.chores.remove
</verification>

<success_criteria>
- Mutation queue persists to IndexedDB (survives page refresh)
- Sync engine processes queue when online
- Failed mutations are retried up to 3 times
- Convex chores table deployed with CRUD mutations
- Online/offline status tracked reactively
- Sync status exposed (isSyncing, pendingCount, failedCount, lastSyncedAt)
</success_criteria>

<output>
After completion, create `.planning/phases/02-data-layer/02-02-SUMMARY.md`
</output>
