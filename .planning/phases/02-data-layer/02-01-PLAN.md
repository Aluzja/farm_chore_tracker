---
phase: 02-data-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - bun.lock
  - src/lib/db/schema.ts
  - src/lib/db/client.ts
  - src/lib/db/operations.ts
  - src/lib/db/storage.ts
autonomous: true

must_haves:
  truths:
    - "IndexedDB database opens without errors"
    - "Data written to IndexedDB persists across page refreshes"
    - "Zod validates data at storage boundaries"
  artifacts:
    - path: "src/lib/db/schema.ts"
      provides: "Zod schemas and store configuration"
      exports: ["ChoreSchema", "MutationSchema", "STORES", "DB_NAME", "DB_VERSION"]
    - path: "src/lib/db/client.ts"
      provides: "idb wrapper with typed database interface"
      exports: ["getDB", "initDB"]
    - path: "src/lib/db/operations.ts"
      provides: "CRUD operations for IndexedDB"
      exports: ["getChore", "getAllChores", "putChore", "deleteChore"]
    - path: "src/lib/db/storage.ts"
      provides: "Storage persistence and quota utilities"
      exports: ["requestPersistentStorage", "getStorageEstimate"]
  key_links:
    - from: "src/lib/db/operations.ts"
      to: "src/lib/db/client.ts"
      via: "getDB() call"
      pattern: "getDB\\(\\)"
    - from: "src/lib/db/operations.ts"
      to: "src/lib/db/schema.ts"
      via: "Zod validation"
      pattern: "ChoreSchema\\.parse"
---

<objective>
Create IndexedDB persistence layer with idb wrapper and Zod validation for offline-first data storage.

Purpose: Establish the local data store that serves as the source of truth when offline. This is the foundation layer that the sync engine and reactive stores build upon.

Output: Complete IndexedDB infrastructure with typed schemas, CRUD operations, and storage management utilities.
</objective>

<execution_context>
@/Users/mike.wojnarowski/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike.wojnarowski/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-data-layer/02-RESEARCH.md

# Existing files to understand
@src/convex/schema.ts (reference for data structure)
@src/routes/+layout.svelte (browser guard pattern)
@package.json (add dependencies here)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install idb and Zod dependencies</name>
  <files>package.json, bun.lock</files>
  <action>
Install the idb and zod packages using bun:

```bash
bun add idb zod
```

This adds:
- idb@^8.0.3 - Promise-based IndexedDB wrapper by Jake Archibald
- zod@^4.3.6 - TypeScript-first schema validation (user decision from STATE.md)

After install, run `bun run check` to verify TypeScript still passes.
  </action>
  <verify>
- `bun run check` exits 0
- package.json shows idb and zod in dependencies
- `bun run build` succeeds (or note if pre-existing build issues persist)
  </verify>
  <done>idb and zod installed and project compiles</done>
</task>

<task type="auto">
  <name>Task 2: Create IndexedDB schema and client</name>
  <files>src/lib/db/schema.ts, src/lib/db/client.ts</files>
  <action>
Create the db directory and two core files:

**src/lib/db/schema.ts:**
```typescript
import { z } from 'zod';

export const DB_NAME = 'kitchen-sink-farm';
export const DB_VERSION = 1;

// Chore schema - mirrors Convex but adds sync metadata
export const ChoreSchema = z.object({
  _id: z.string(),
  text: z.string().min(1),
  isCompleted: z.boolean(),
  completedAt: z.string().datetime().optional(),
  completedBy: z.string().optional(),
  // Local-only sync tracking
  syncStatus: z.enum(['pending', 'synced', 'failed']),
  lastModified: z.number(),
});

// Mutation queue entry for offline mutations
export const MutationSchema = z.object({
  id: z.string().uuid(),
  type: z.enum(['create', 'update', 'delete']),
  table: z.string(),
  payload: z.record(z.unknown()),
  createdAt: z.number(),
  retryCount: z.number().default(0),
});

export type Chore = z.infer<typeof ChoreSchema>;
export type Mutation = z.infer<typeof MutationSchema>;

export const STORES = {
  chores: 'chores',
  mutationQueue: 'mutationQueue',
} as const;
```

**src/lib/db/client.ts:**
```typescript
import { openDB, type IDBPDatabase, type DBSchema } from 'idb';
import { DB_NAME, DB_VERSION, STORES, type Chore, type Mutation } from './schema';

interface KitchenSinkDB extends DBSchema {
  chores: {
    key: string;
    value: Chore;
    indexes: {
      'by-sync-status': string;
      'by-last-modified': number;
    };
  };
  mutationQueue: {
    key: string;
    value: Mutation;
    indexes: {
      'by-created-at': number;
    };
  };
}

let dbPromise: Promise<IDBPDatabase<KitchenSinkDB>> | null = null;

export function getDB(): Promise<IDBPDatabase<KitchenSinkDB>> {
  if (!dbPromise) {
    dbPromise = openDB<KitchenSinkDB>(DB_NAME, DB_VERSION, {
      upgrade(db, oldVersion) {
        // Version 1: Initial schema
        if (oldVersion < 1) {
          const choreStore = db.createObjectStore(STORES.chores, { keyPath: '_id' });
          choreStore.createIndex('by-sync-status', 'syncStatus');
          choreStore.createIndex('by-last-modified', 'lastModified');

          const queueStore = db.createObjectStore(STORES.mutationQueue, { keyPath: 'id' });
          queueStore.createIndex('by-created-at', 'createdAt');
        }
        // Future migrations: if (oldVersion < 2) { ... }
      },
      blocked() {
        console.warn('[DB] Database blocked - close other tabs');
      },
      blocking() {
        console.warn('[DB] Database blocking - this tab has old version');
      },
    });
  }
  return dbPromise;
}

// For testing: reset the cached promise
export function resetDB(): void {
  dbPromise = null;
}

export type { KitchenSinkDB };
```

Key patterns:
- DBSchema interface provides full TypeScript typing for idb
- Singleton pattern via module-level dbPromise (lazy initialization)
- Index on syncStatus for querying pending items
- Index on lastModified for ordering
- Version-based migrations for future schema changes
  </action>
  <verify>
- `bun run check` passes with no type errors
- Both files exist with correct exports
- Import { getDB } from '$lib/db/client' resolves (check with bun run check)
  </verify>
  <done>Schema and client files created with full TypeScript typing</done>
</task>

<task type="auto">
  <name>Task 3: Create CRUD operations and storage utilities</name>
  <files>src/lib/db/operations.ts, src/lib/db/storage.ts</files>
  <action>
**src/lib/db/operations.ts:**
```typescript
import { getDB } from './client';
import { STORES, ChoreSchema, type Chore } from './schema';

// Read operations
export async function getChore(id: string): Promise<Chore | undefined> {
  const db = await getDB();
  const chore = await db.get(STORES.chores, id);
  return chore ? ChoreSchema.parse(chore) : undefined;
}

export async function getAllChores(): Promise<Chore[]> {
  const db = await getDB();
  const chores = await db.getAll(STORES.chores);
  return chores.map(c => ChoreSchema.parse(c));
}

export async function getChoresByStatus(status: Chore['syncStatus']): Promise<Chore[]> {
  const db = await getDB();
  const chores = await db.getAllFromIndex(STORES.chores, 'by-sync-status', status);
  return chores.map(c => ChoreSchema.parse(c));
}

// Write operations
export async function putChore(chore: Chore): Promise<void> {
  // Validate before storing
  const validated = ChoreSchema.parse(chore);
  const db = await getDB();
  await db.put(STORES.chores, validated);
}

export async function deleteChore(id: string): Promise<void> {
  const db = await getDB();
  await db.delete(STORES.chores, id);
}

// Batch operations for sync
export async function putChores(chores: Chore[]): Promise<void> {
  const db = await getDB();
  const tx = db.transaction(STORES.chores, 'readwrite');
  await Promise.all([
    ...chores.map(c => tx.store.put(ChoreSchema.parse(c))),
    tx.done,
  ]);
}

export async function clearChores(): Promise<void> {
  const db = await getDB();
  await db.clear(STORES.chores);
}
```

**src/lib/db/storage.ts:**
```typescript
import { browser } from '$app/environment';

export async function requestPersistentStorage(): Promise<boolean> {
  if (!browser || !navigator.storage?.persist) {
    console.warn('[Storage] Persistent storage API not available');
    return false;
  }

  const isPersisted = await navigator.storage.persisted();
  if (isPersisted) {
    return true;
  }

  const granted = await navigator.storage.persist();
  if (granted) {
    console.log('[Storage] Persistent storage granted');
  } else {
    console.warn('[Storage] Persistent storage denied - data may be evicted');
  }
  return granted;
}

export async function getStorageEstimate(): Promise<{ usage: number; quota: number }> {
  if (!browser || !navigator.storage?.estimate) {
    return { usage: 0, quota: 0 };
  }
  const { usage = 0, quota = 0 } = await navigator.storage.estimate();
  return { usage, quota };
}

export function formatStorageSize(bytes: number): string {
  if (bytes < 1024) return `${bytes} B`;
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
}
```

Key patterns:
- All read operations validate with Zod (guards against corrupted data)
- Transaction for batch writes (atomic operations)
- Browser guard for storage APIs (SSR safety)
- Storage utilities for quota monitoring (iOS Safari needs this)
  </action>
  <verify>
- `bun run check` passes
- All exports are typed correctly
- No circular dependencies (operations imports client, not vice versa)
  </verify>
  <done>CRUD operations and storage utilities complete with Zod validation at all boundaries</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Type check passes:**
   ```bash
   bun run check
   ```
   Expected: 0 errors, 0 warnings

2. **Build succeeds:**
   ```bash
   bun run build
   ```
   Expected: Build completes (note any pre-existing issues from Phase 1)

3. **Exports are correct:**
   Create a quick verification by checking that imports resolve:
   ```bash
   # Check that the module structure is correct
   bun run check
   ```

4. **File structure:**
   ```
   src/lib/db/
   ├── schema.ts     (Zod schemas, types, constants)
   ├── client.ts     (idb wrapper, getDB)
   ├── operations.ts (CRUD with validation)
   └── storage.ts    (persistence utilities)
   ```
</verification>

<success_criteria>
- idb@^8.0.3 and zod@^4.3.6 in package.json dependencies
- Four files in src/lib/db/ with correct exports
- All imports resolve without TypeScript errors
- Zod validation applied to all data entering/exiting IndexedDB
- No circular dependencies between modules
</success_criteria>

<output>
After completion, create `.planning/phases/02-data-layer/02-01-SUMMARY.md`
</output>
