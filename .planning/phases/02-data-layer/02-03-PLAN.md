---
phase: 02-data-layer
plan: 03
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - src/lib/stores/chores.svelte.ts
  - src/lib/stores/index.ts
  - src/routes/+layout.svelte
  - src/routes/+page.svelte
autonomous: false

must_haves:
  truths:
    - "Chore data loads instantly from IndexedDB on page load"
    - "Real-time updates from Convex appear within seconds when online"
    - "Mutations update UI optimistically then queue for sync"
    - "Sync status is visible to user (pending count, last sync time)"
  artifacts:
    - path: "src/lib/stores/chores.svelte.ts"
      provides: "Reactive chore store wrapping IndexedDB"
      exports: ["choreStore"]
    - path: "src/lib/stores/index.ts"
      provides: "Store barrel export"
      exports: ["choreStore"]
    - path: "src/routes/+page.svelte"
      provides: "Test UI demonstrating offline-first behavior"
      min_lines: 50
  key_links:
    - from: "src/lib/stores/chores.svelte.ts"
      to: "src/lib/db/operations.ts"
      via: "IndexedDB read/write"
      pattern: "getAllChores|putChore"
    - from: "src/lib/stores/chores.svelte.ts"
      to: "src/lib/sync/queue.ts"
      via: "Mutation queueing"
      pattern: "enqueueMutation"
    - from: "src/lib/stores/chores.svelte.ts"
      to: "convex-svelte"
      via: "Real-time subscription"
      pattern: "useQuery"
    - from: "src/routes/+layout.svelte"
      to: "src/lib/sync/engine.svelte.ts"
      via: "Sync engine initialization"
      pattern: "syncEngine\\.init"

user_setup: []
---

<objective>
Create reactive Svelte 5 stores wrapping the offline-first data layer with real-time hydration from Convex.

Purpose: Provide the UI layer with reactive data that loads instantly from local storage, updates optimistically, and syncs seamlessly with the server.

Output: Complete reactive data layer with test UI demonstrating offline-first behavior.
</objective>

<execution_context>
@/Users/mike.wojnarowski/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike.wojnarowski/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-data-layer/02-RESEARCH.md

# From Plan 01 (dependency)
@src/lib/db/schema.ts (Chore type)
@src/lib/db/operations.ts (getAllChores, putChore, deleteChore)

# From Plan 02 (dependency)
@src/lib/sync/queue.ts (enqueueMutation)
@src/lib/sync/engine.svelte.ts (syncEngine)
@src/lib/sync/status.svelte.ts (connectionStatus)
@src/convex/chores.ts (api.chores.list)

# Existing layout
@src/routes/+layout.svelte (add sync init here)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reactive chore store</name>
  <files>src/lib/stores/chores.svelte.ts, src/lib/stores/index.ts</files>
  <action>
Create reactive store that bridges IndexedDB, Convex, and the UI:

**src/lib/stores/chores.svelte.ts:**
```typescript
import { browser } from '$app/environment';
import {
  getAllChores,
  putChore,
  putChores,
  deleteChore,
  getChore,
} from '$lib/db/operations';
import { enqueueMutation } from '$lib/sync/queue';
import type { Chore } from '$lib/db/schema';

class ChoreStore {
  items = $state<Chore[]>([]);
  isLoading = $state(true);
  error = $state<Error | null>(null);
  lastLoadedAt = $state<number | null>(null);

  // Load from IndexedDB (instant, offline-first)
  async load(): Promise<void> {
    if (!browser) return;

    try {
      this.isLoading = true;
      this.error = null;
      const chores = await getAllChores();
      this.items = chores.sort((a, b) => b.lastModified - a.lastModified);
      this.lastLoadedAt = Date.now();
    } catch (e) {
      this.error = e instanceof Error ? e : new Error(String(e));
      console.error('[ChoreStore] Load error:', e);
    } finally {
      this.isLoading = false;
    }
  }

  // Hydrate from Convex server data (called when online)
  async hydrateFromServer(serverChores: Array<{
    _id: string;
    text: string;
    isCompleted: boolean;
    completedAt?: string;
    completedBy?: string;
    lastModified: number;
  }>): Promise<void> {
    if (!browser || serverChores.length === 0) return;

    try {
      // Convert server chores to local format with synced status
      const localChores: Chore[] = serverChores.map(sc => ({
        _id: sc._id,
        text: sc.text,
        isCompleted: sc.isCompleted,
        completedAt: sc.completedAt,
        completedBy: sc.completedBy,
        syncStatus: 'synced' as const,
        lastModified: sc.lastModified,
      }));

      // Merge with local data (server wins for same _id with newer timestamp)
      const localMap = new Map(this.items.map(c => [c._id, c]));

      for (const serverChore of localChores) {
        const local = localMap.get(serverChore._id);
        if (!local || serverChore.lastModified >= local.lastModified) {
          localMap.set(serverChore._id, serverChore);
        }
        // If local is pending and newer, keep local (will sync to server)
      }

      const merged = Array.from(localMap.values());

      // Persist merged data to IndexedDB
      await putChores(merged);

      // Update reactive state
      this.items = merged.sort((a, b) => b.lastModified - a.lastModified);
      this.lastLoadedAt = Date.now();
    } catch (e) {
      console.error('[ChoreStore] Hydration error:', e);
      // Don't set error - hydration failure shouldn't break the app
    }
  }

  // Add new chore (optimistic + queue)
  async add(text: string, completedBy?: string): Promise<string> {
    const newChore: Chore = {
      _id: crypto.randomUUID(),
      text,
      isCompleted: false,
      completedBy,
      syncStatus: 'pending',
      lastModified: Date.now(),
    };

    // Optimistic UI update
    this.items = [newChore, ...this.items];

    // Persist to IndexedDB
    await putChore(newChore);

    // Queue for sync
    await enqueueMutation('create', 'chores', {
      _id: newChore._id,
      text: newChore.text,
      isCompleted: newChore.isCompleted,
      completedBy: newChore.completedBy,
      lastModified: newChore.lastModified,
    });

    return newChore._id;
  }

  // Toggle completion (optimistic + queue)
  async toggleComplete(id: string, completedBy?: string): Promise<void> {
    const chore = this.items.find(c => c._id === id);
    if (!chore) return;

    const now = Date.now();
    const updated: Chore = {
      ...chore,
      isCompleted: !chore.isCompleted,
      completedAt: !chore.isCompleted ? new Date(now).toISOString() : undefined,
      completedBy: !chore.isCompleted ? completedBy : undefined,
      syncStatus: 'pending',
      lastModified: now,
    };

    // Optimistic UI update - use $state.snapshot to avoid proxy issues
    this.items = this.items.map(c => c._id === id ? updated : c);

    // Persist to IndexedDB (use snapshot to avoid storing Proxy)
    await putChore($state.snapshot(updated));

    // Queue for sync
    await enqueueMutation('update', 'chores', {
      id: updated._id,
      isCompleted: updated.isCompleted,
      completedAt: updated.completedAt,
      completedBy: updated.completedBy,
      lastModified: updated.lastModified,
    });
  }

  // Update chore text (optimistic + queue)
  async updateText(id: string, text: string): Promise<void> {
    const chore = this.items.find(c => c._id === id);
    if (!chore) return;

    const updated: Chore = {
      ...chore,
      text,
      syncStatus: 'pending',
      lastModified: Date.now(),
    };

    this.items = this.items.map(c => c._id === id ? updated : c);
    await putChore($state.snapshot(updated));

    await enqueueMutation('update', 'chores', {
      id: updated._id,
      text: updated.text,
      lastModified: updated.lastModified,
    });
  }

  // Delete chore (optimistic + queue)
  async remove(id: string): Promise<void> {
    // Optimistic UI update
    this.items = this.items.filter(c => c._id !== id);

    // Remove from IndexedDB
    await deleteChore(id);

    // Queue for sync
    await enqueueMutation('delete', 'chores', { id });
  }

  // Get chore by ID (reactive derived would be better, but simple for now)
  getById(id: string): Chore | undefined {
    return this.items.find(c => c._id === id);
  }

  // Computed stats
  get completedCount(): number {
    return this.items.filter(c => c.isCompleted).length;
  }

  get pendingCount(): number {
    return this.items.filter(c => c.syncStatus === 'pending').length;
  }

  get failedCount(): number {
    return this.items.filter(c => c.syncStatus === 'failed').length;
  }
}

export const choreStore = new ChoreStore();
```

**src/lib/stores/index.ts:**
```typescript
export { choreStore } from './chores.svelte';
```

Key patterns:
- Class-based store with $state runes
- Optimistic updates (instant UI feedback)
- $state.snapshot() before IndexedDB writes (avoid Proxy issues)
- Hydration merges server data respecting timestamps
- All mutations queue for sync
  </action>
  <verify>
- `bun run check` passes
- choreStore exports correctly
- $state.snapshot used for IndexedDB writes
  </verify>
  <done>Reactive chore store with optimistic updates and sync queueing</done>
</task>

<task type="auto">
  <name>Task 2: Initialize sync engine and add hydration to layout</name>
  <files>src/routes/+layout.svelte</files>
  <action>
Update root layout to initialize sync engine and set up Convex hydration:

**src/routes/+layout.svelte** (replace existing):
```svelte
<script lang="ts">
  import { onMount } from 'svelte';
  import { setupConvex, useQuery } from 'convex-svelte';
  import { PUBLIC_CONVEX_URL } from '$env/static/public';
  import { browser } from '$app/environment';
  import { pwaInfo } from 'virtual:pwa-info';
  import { syncEngine } from '$lib/sync/engine.svelte';
  import { choreStore } from '$lib/stores/chores.svelte';
  import { connectionStatus } from '$lib/sync/status.svelte';
  import { requestPersistentStorage } from '$lib/db/storage';
  import { api } from '../convex/_generated/api';
  import favicon from '$lib/assets/favicon.svg';

  let { children } = $props();

  let webManifestLink = $derived(pwaInfo ? pwaInfo.webManifest.linkTag : '');

  // Only initialize on client side
  if (browser) {
    setupConvex(PUBLIC_CONVEX_URL);
  }

  // Server chores subscription (only active when online)
  const serverChores = browser ? useQuery(api.chores.list, {}) : { data: undefined, isLoading: true };

  // Hydrate from server when data arrives
  $effect(() => {
    if (browser && serverChores.data && connectionStatus.isOnline) {
      choreStore.hydrateFromServer(serverChores.data);
    }
  });

  onMount(async () => {
    // Request persistent storage for IndexedDB
    await requestPersistentStorage();

    // Load local data first (instant)
    await choreStore.load();

    // Initialize sync engine (will process queue if online)
    await syncEngine.init();

    // Register service worker
    if (pwaInfo) {
      const { registerSW } = await import('virtual:pwa-register');
      registerSW({
        immediate: true,
        onRegistered(registration) {
          console.log('[PWA] Service worker registered:', registration?.scope);
        },
        onRegisterError(error) {
          console.error('[PWA] Service worker registration error:', error);
        }
      });
    }
  });
</script>

<svelte:head>
  {@html webManifestLink}
  <link rel="icon" href={favicon} />
</svelte:head>

{@render children?.()}
```

Key patterns:
- Local load happens first in onMount (instant)
- Convex subscription runs in parallel
- $effect hydrates when server data arrives
- Sync engine starts after local data loaded
- Persistent storage requested early
  </action>
  <verify>
- `bun run check` passes
- No SSR errors (browser guards in place)
- App loads without errors in browser
  </verify>
  <done>Layout updated with sync initialization and Convex hydration</done>
</task>

<task type="auto">
  <name>Task 3: Create test page demonstrating offline-first behavior</name>
  <files>src/routes/+page.svelte</files>
  <action>
Replace the test page with a comprehensive offline-first demo:

**src/routes/+page.svelte** (replace existing):
```svelte
<script lang="ts">
  import { choreStore } from '$lib/stores/chores.svelte';
  import { syncEngine } from '$lib/sync/engine.svelte';
  import { connectionStatus } from '$lib/sync/status.svelte';
  import { getStorageEstimate, formatStorageSize } from '$lib/db/storage';
  import { browser } from '$app/environment';

  let newChoreText = $state('');
  let storageInfo = $state({ usage: 0, quota: 0 });

  // Load storage info
  $effect(() => {
    if (browser) {
      getStorageEstimate().then(info => {
        storageInfo = info;
      });
    }
  });

  async function handleAddChore() {
    if (!newChoreText.trim()) return;
    await choreStore.add(newChoreText.trim());
    newChoreText = '';
  }

  async function handleToggle(id: string) {
    await choreStore.toggleComplete(id);
  }

  async function handleDelete(id: string) {
    await choreStore.remove(id);
  }

  async function handleRetryFailed() {
    const count = await syncEngine.retryFailed();
    console.log(`[Test] Retried ${count} failed mutations`);
  }

  function formatTime(timestamp: number | null): string {
    if (!timestamp) return 'Never';
    return new Date(timestamp).toLocaleTimeString();
  }
</script>

<main class="container">
  <h1>Kitchen Sink Farm - Data Layer Test</h1>

  <!-- Connection Status -->
  <section class="status-panel">
    <h2>System Status</h2>
    <div class="status-grid">
      <div class="status-item" class:online={connectionStatus.isOnline} class:offline={!connectionStatus.isOnline}>
        <span class="status-label">Connection</span>
        <span class="status-value">{connectionStatus.isOnline ? 'Online' : 'Offline'}</span>
      </div>
      <div class="status-item" class:syncing={syncEngine.isSyncing}>
        <span class="status-label">Sync</span>
        <span class="status-value">{syncEngine.isSyncing ? 'Syncing...' : 'Idle'}</span>
      </div>
      <div class="status-item">
        <span class="status-label">Pending</span>
        <span class="status-value">{syncEngine.pendingCount}</span>
      </div>
      <div class="status-item" class:has-failed={syncEngine.failedCount > 0}>
        <span class="status-label">Failed</span>
        <span class="status-value">{syncEngine.failedCount}</span>
        {#if syncEngine.failedCount > 0}
          <button class="retry-btn" onclick={handleRetryFailed}>Retry</button>
        {/if}
      </div>
      <div class="status-item">
        <span class="status-label">Last Sync</span>
        <span class="status-value">{formatTime(syncEngine.lastSyncedAt)}</span>
      </div>
      <div class="status-item">
        <span class="status-label">Storage</span>
        <span class="status-value">{formatStorageSize(storageInfo.usage)} / {formatStorageSize(storageInfo.quota)}</span>
      </div>
    </div>
    {#if syncEngine.lastError}
      <div class="error-banner">
        Error: {syncEngine.lastError}
      </div>
    {/if}
  </section>

  <!-- Add Chore -->
  <section class="add-chore">
    <h2>Add Chore</h2>
    <form onsubmit={(e) => { e.preventDefault(); handleAddChore(); }}>
      <input
        type="text"
        bind:value={newChoreText}
        placeholder="Enter chore description..."
        class="chore-input"
      />
      <button type="submit" class="add-btn" disabled={!newChoreText.trim()}>
        Add Chore
      </button>
    </form>
  </section>

  <!-- Chore List -->
  <section class="chore-list">
    <h2>
      Chores
      <span class="count">({choreStore.completedCount}/{choreStore.items.length} complete)</span>
    </h2>

    {#if choreStore.isLoading}
      <div class="loading">Loading from local storage...</div>
    {:else if choreStore.error}
      <div class="error">Error: {choreStore.error.message}</div>
    {:else if choreStore.items.length === 0}
      <div class="empty">No chores yet. Add one above!</div>
    {:else}
      <ul class="chores">
        {#each choreStore.items as chore (chore._id)}
          <li class="chore-item" class:completed={chore.isCompleted}>
            <button
              class="toggle-btn"
              onclick={() => handleToggle(chore._id)}
              aria-label={chore.isCompleted ? 'Mark incomplete' : 'Mark complete'}
            >
              {chore.isCompleted ? '✓' : '○'}
            </button>
            <span class="chore-text">{chore.text}</span>
            <span class="sync-status" class:pending={chore.syncStatus === 'pending'} class:failed={chore.syncStatus === 'failed'}>
              {#if chore.syncStatus === 'pending'}
                ⏳
              {:else if chore.syncStatus === 'failed'}
                ❌
              {:else}
                ✓
              {/if}
            </span>
            <button
              class="delete-btn"
              onclick={() => handleDelete(chore._id)}
              aria-label="Delete chore"
            >
              ×
            </button>
          </li>
        {/each}
      </ul>
    {/if}
  </section>

  <!-- Instructions -->
  <section class="instructions">
    <h2>Testing Offline-First Behavior</h2>
    <ol>
      <li><strong>Add a chore</strong> - It appears instantly (optimistic update)</li>
      <li><strong>Check "Pending"</strong> - Shows unsynchronized mutations</li>
      <li><strong>Go offline</strong> (DevTools > Network > Offline) - Add more chores</li>
      <li><strong>Refresh page</strong> - Chores persist from IndexedDB!</li>
      <li><strong>Go online</strong> - Watch "Pending" count decrease as sync runs</li>
      <li><strong>Open another tab</strong> - Changes sync via Convex in real-time</li>
    </ol>
  </section>
</main>

<style>
  .container {
    max-width: 800px;
    margin: 0 auto;
    padding: 1rem;
    font-family: system-ui, -apple-system, sans-serif;
  }

  h1 {
    color: #4CAF50;
    margin-bottom: 1.5rem;
  }

  h2 {
    font-size: 1.25rem;
    margin-bottom: 0.75rem;
    color: #333;
  }

  section {
    background: #f9f9f9;
    border-radius: 8px;
    padding: 1rem;
    margin-bottom: 1rem;
  }

  /* Status Panel */
  .status-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 0.75rem;
  }

  .status-item {
    background: white;
    padding: 0.5rem;
    border-radius: 4px;
    text-align: center;
    border: 1px solid #ddd;
  }

  .status-item.online { border-color: #4CAF50; background: #E8F5E9; }
  .status-item.offline { border-color: #f44336; background: #FFEBEE; }
  .status-item.syncing { border-color: #2196F3; background: #E3F2FD; }
  .status-item.has-failed { border-color: #ff9800; background: #FFF3E0; }

  .status-label {
    display: block;
    font-size: 0.75rem;
    color: #666;
    text-transform: uppercase;
  }

  .status-value {
    display: block;
    font-weight: 600;
    font-size: 1rem;
  }

  .retry-btn {
    margin-top: 0.25rem;
    padding: 0.25rem 0.5rem;
    font-size: 0.75rem;
    background: #ff9800;
    color: white;
    border: none;
    border-radius: 3px;
    cursor: pointer;
  }

  .error-banner {
    margin-top: 0.75rem;
    padding: 0.5rem;
    background: #FFEBEE;
    color: #c62828;
    border-radius: 4px;
  }

  /* Add Chore */
  .add-chore form {
    display: flex;
    gap: 0.5rem;
  }

  .chore-input {
    flex: 1;
    padding: 0.75rem;
    font-size: 1rem;
    border: 1px solid #ddd;
    border-radius: 4px;
  }

  .add-btn {
    padding: 0.75rem 1.5rem;
    font-size: 1rem;
    background: #4CAF50;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
  }

  .add-btn:disabled {
    background: #ccc;
    cursor: not-allowed;
  }

  /* Chore List */
  .count {
    font-weight: normal;
    font-size: 1rem;
    color: #666;
  }

  .loading, .error, .empty {
    padding: 2rem;
    text-align: center;
    color: #666;
  }

  .error {
    color: #c62828;
  }

  .chores {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .chore-item {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.75rem;
    background: white;
    border-radius: 4px;
    margin-bottom: 0.5rem;
    border: 1px solid #ddd;
  }

  .chore-item.completed {
    background: #f5f5f5;
  }

  .chore-item.completed .chore-text {
    text-decoration: line-through;
    color: #999;
  }

  .toggle-btn {
    width: 2rem;
    height: 2rem;
    border-radius: 50%;
    border: 2px solid #4CAF50;
    background: white;
    font-size: 1rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .chore-item.completed .toggle-btn {
    background: #4CAF50;
    color: white;
  }

  .chore-text {
    flex: 1;
  }

  .sync-status {
    font-size: 0.875rem;
    opacity: 0.6;
  }

  .sync-status.pending {
    opacity: 1;
  }

  .sync-status.failed {
    opacity: 1;
    color: #f44336;
  }

  .delete-btn {
    width: 2rem;
    height: 2rem;
    border-radius: 4px;
    border: none;
    background: #ffebee;
    color: #c62828;
    font-size: 1.25rem;
    cursor: pointer;
  }

  /* Instructions */
  .instructions ol {
    padding-left: 1.5rem;
  }

  .instructions li {
    margin-bottom: 0.5rem;
  }
</style>
```

Key patterns:
- Real-time reactive UI via $state
- Sync status always visible
- Visual indicators for sync state per item
- Manual retry for failed mutations
- Storage quota monitoring
- Testing instructions for offline behavior
  </action>
  <verify>
- `bun run check` passes
- `bun run dev` starts without errors
- Page loads and displays status panel
- Adding chores updates UI immediately
  </verify>
  <done>Test page created demonstrating full offline-first data flow</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete three-layer offline-first data architecture:
1. IndexedDB persistence via idb with Zod validation
2. Sync engine with mutation queue and retry logic
3. Reactive Svelte 5 stores with optimistic updates and Convex hydration
  </what-built>
  <how-to-verify>
1. Start dev server: `bun run dev`
2. Open http://localhost:5173

**Test 1: Basic functionality**
- Add a chore - appears instantly with pending indicator (hourglass)
- After ~1 second, pending indicator should change to checkmark (synced)
- Toggle completion - updates immediately
- Delete a chore - removed immediately

**Test 2: Offline persistence**
- Add 2-3 chores
- Refresh the page (Cmd+R)
- Chores should appear immediately from IndexedDB (not wait for network)

**Test 3: Offline mutations**
- Open DevTools > Network tab > check "Offline"
- Add a new chore - appears with pending indicator
- "Pending" count in status panel should be > 0
- Uncheck "Offline"
- Watch "Pending" count decrease to 0

**Test 4: Real-time sync (optional)**
- Open app in two browser tabs
- Add a chore in one tab
- After sync, it should appear in other tab (via Convex subscription)

**Test 5: Storage info**
- Check "Storage" shows usage/quota (not 0/0)
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:

1. **TypeScript check:**
   ```bash
   bun run check
   ```
   Expected: 0 errors

2. **Build:**
   ```bash
   bun run build
   ```
   Expected: Build succeeds

3. **Dev server:**
   ```bash
   bun run dev
   ```
   Expected: Server starts, page loads without errors

4. **File structure:**
   ```
   src/lib/
   ├── db/                    (from Plan 01)
   │   ├── schema.ts
   │   ├── client.ts
   │   ├── operations.ts
   │   └── storage.ts
   ├── sync/                  (from Plan 02)
   │   ├── queue.ts
   │   ├── status.svelte.ts
   │   └── engine.svelte.ts
   └── stores/                (this plan)
       ├── chores.svelte.ts
       └── index.ts
   ```
</verification>

<success_criteria>
**Phase 2 Success Criteria (from ROADMAP.md):**
1. Data persists in IndexedDB across browser restarts - VERIFIED via Test 2
2. Mutations made offline are queued and sync when connectivity returns - VERIFIED via Test 3
3. Real-time updates from other users appear within seconds when online - VERIFIED via Test 4
4. Sync failures are captured and retryable - VERIFIED via retry button in UI
</success_criteria>

<output>
After completion, create `.planning/phases/02-data-layer/02-03-SUMMARY.md`
</output>
