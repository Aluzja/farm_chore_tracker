---
phase: 05-photo-verification
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - src/lib/photo/queue.ts
  - src/lib/photo/upload.ts
  - src/lib/sync/engine.svelte.ts
autonomous: true

must_haves:
  truths:
    - "Photos can be queued in IndexedDB for later upload"
    - "Queued photos upload sequentially when online"
    - "Upload progress is trackable via reactive state"
    - "Failed uploads are retried automatically"
  artifacts:
    - path: "src/lib/photo/queue.ts"
      provides: "Photo queue CRUD operations"
      exports: ["enqueuePhoto", "getPhotoQueue", "removePhoto", "incrementPhotoRetry", "markPhotoFailed"]
    - path: "src/lib/photo/upload.ts"
      provides: "Photo upload to Convex"
      exports: ["uploadPhoto"]
    - path: "src/lib/sync/engine.svelte.ts"
      provides: "Extended sync engine with photo queue processing"
      contains: "processPhotoQueue"
  key_links:
    - from: "src/lib/sync/engine.svelte.ts"
      to: "src/lib/photo/queue.ts"
      via: "photo queue processing"
      pattern: "getPhotoQueue|removePhoto"
    - from: "src/lib/photo/upload.ts"
      to: "api.photos"
      via: "Convex mutations"
      pattern: "api.photos.generateUploadUrl|api.photos.attachPhotoToChore"
---

<objective>
Create photo upload queue system that persists photos in IndexedDB and uploads them to Convex when online, with retry logic and progress tracking.

Purpose: Offline-first photo handling - photos taken without connectivity are queued and automatically upload when connection is restored.
Output: Photo queue operations, upload module, extended sync engine with photo queue processing.
</objective>

<execution_context>
@/Users/mike.wojnarowski/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike.wojnarowski/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-photo-verification/05-RESEARCH.md

@src/lib/db/schema.ts
@src/lib/db/client.ts
@src/lib/sync/engine.svelte.ts
@src/lib/sync/queue.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create photo queue operations</name>
  <files>
    src/lib/photo/queue.ts
  </files>
  <action>
Create `src/lib/photo/queue.ts` following the existing mutation queue pattern from `src/lib/sync/queue.ts`:

```typescript
import { browser } from '$app/environment';
import { getDB } from '$lib/db/client';
import type { PhotoQueueEntry } from '$lib/db/schema';

/**
 * Add a photo to the upload queue.
 */
export async function enqueuePhoto(entry: Omit<PhotoQueueEntry, 'retryCount' | 'lastAttemptAt'>): Promise<void> {
  if (!browser) return;
  const db = await getDB();
  await db.put('photoQueue', {
    ...entry,
    retryCount: 0,
  });
}

/**
 * Get all photos pending upload, ordered by capture time.
 */
export async function getPhotoQueue(): Promise<PhotoQueueEntry[]> {
  if (!browser) return [];
  const db = await getDB();
  return db.getAllFromIndex('photoQueue', 'by-captured-at');
}

/**
 * Get count of pending photos (not failed).
 */
export async function getPendingPhotoCount(): Promise<number> {
  if (!browser) return 0;
  const db = await getDB();
  const all = await db.getAllFromIndex('photoQueue', 'by-upload-status', 'pending');
  return all.length;
}

/**
 * Remove a photo from the queue after successful upload.
 */
export async function removePhoto(id: string): Promise<void> {
  if (!browser) return;
  const db = await getDB();
  await db.delete('photoQueue', id);
}

/**
 * Increment retry count and update status.
 */
export async function incrementPhotoRetry(id: string): Promise<number> {
  if (!browser) return 0;
  const db = await getDB();
  const entry = await db.get('photoQueue', id);
  if (!entry) return 0;

  const updated: PhotoQueueEntry = {
    ...entry,
    retryCount: entry.retryCount + 1,
    lastAttemptAt: Date.now(),
  };
  await db.put('photoQueue', updated);
  return updated.retryCount;
}

/**
 * Mark a photo upload as failed (after max retries).
 */
export async function markPhotoFailed(id: string): Promise<void> {
  if (!browser) return;
  const db = await getDB();
  const entry = await db.get('photoQueue', id);
  if (!entry) return;

  await db.put('photoQueue', {
    ...entry,
    uploadStatus: 'failed',
    lastAttemptAt: Date.now(),
  });
}

/**
 * Update status to 'uploading' when upload starts.
 */
export async function markPhotoUploading(id: string): Promise<void> {
  if (!browser) return;
  const db = await getDB();
  const entry = await db.get('photoQueue', id);
  if (!entry) return;

  await db.put('photoQueue', {
    ...entry,
    uploadStatus: 'uploading',
  });
}

/**
 * Get count of failed photo uploads.
 */
export async function getFailedPhotoCount(): Promise<number> {
  if (!browser) return 0;
  const db = await getDB();
  const all = await db.getAllFromIndex('photoQueue', 'by-upload-status', 'failed');
  return all.length;
}

/**
 * Reset failed photos for retry.
 */
export async function resetFailedPhotos(): Promise<number> {
  if (!browser) return 0;
  const db = await getDB();
  const failed = await db.getAllFromIndex('photoQueue', 'by-upload-status', 'failed');

  for (const entry of failed) {
    await db.put('photoQueue', {
      ...entry,
      uploadStatus: 'pending',
      retryCount: 0,
    });
  }

  return failed.length;
}
```
  </action>
  <verify>
Run `npm run build` - should compile without errors.
Run `npm run check` - TypeScript should pass.
Verify all queue functions are exported.
  </verify>
  <done>
Photo queue operations match mutation queue pattern.
Functions handle browser guard and IndexedDB operations.
All CRUD operations for photo queue implemented.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create photo upload module</name>
  <files>
    src/lib/photo/upload.ts
  </files>
  <action>
Create `src/lib/photo/upload.ts` for uploading photos to Convex:

```typescript
import type { ConvexClient } from 'convex/browser';
import { api } from '../../convex/_generated/api';
import type { Id } from '../../convex/_generated/dataModel';

export interface PhotoUploadResult {
  storageId: Id<"_storage">;
  success: boolean;
}

/**
 * Upload a photo blob to Convex file storage and attach it to a daily chore.
 *
 * This uses Convex's three-step upload pattern:
 * 1. Generate a short-lived upload URL
 * 2. POST the blob to that URL
 * 3. Attach the resulting storageId to the daily chore
 */
export async function uploadPhoto(
  client: ConvexClient,
  blob: Blob,
  dailyChoreClientId: string,
  capturedAt: number,
  capturedBy: string,
): Promise<PhotoUploadResult> {
  // Step 1: Get upload URL from Convex
  const uploadUrl = await client.mutation(api.photos.generateUploadUrl);

  // Step 2: Upload blob to the URL
  const response = await fetch(uploadUrl, {
    method: 'POST',
    headers: { 'Content-Type': blob.type },
    body: blob,
  });

  if (!response.ok) {
    throw new Error(`Photo upload failed: ${response.status} ${response.statusText}`);
  }

  const { storageId } = await response.json() as { storageId: Id<"_storage"> };

  // Step 3: Attach photo to the daily chore
  await client.mutation(api.photos.attachPhotoToChore, {
    dailyChoreClientId,
    storageId,
    capturedAt,
    capturedBy,
  });

  return { storageId, success: true };
}

/**
 * Get the URL for viewing a photo.
 */
export async function getPhotoViewUrl(
  client: ConvexClient,
  storageId: Id<"_storage">,
): Promise<string | null> {
  return await client.query(api.photos.getPhotoUrl, { storageId });
}
```

Reference: Research section "Pattern 2: Convex Upload URL Flow"
  </action>
  <verify>
Run `npm run build` - should compile without errors.
Run `npm run check` - TypeScript should pass.
Verify uploadPhoto and getPhotoViewUrl are exported.
  </verify>
  <done>
Photo upload module implements Convex three-step upload pattern.
Handles URL generation, blob upload, and chore attachment.
Error handling for upload failures.
  </done>
</task>

<task type="auto">
  <name>Task 3: Extend sync engine with photo queue processing</name>
  <files>
    src/lib/sync/engine.svelte.ts
  </files>
  <action>
Update `src/lib/sync/engine.svelte.ts` to process photo uploads:

1. Add new reactive state for photo sync:
```typescript
pendingPhotoCount = $state(0);
failedPhotoCount = $state(0);
currentPhotoUpload = $state<string | null>(null); // ID of photo being uploaded
```

2. Import photo queue functions:
```typescript
import {
  getPhotoQueue,
  removePhoto,
  incrementPhotoRetry,
  markPhotoFailed,
  markPhotoUploading,
  getPendingPhotoCount,
  getFailedPhotoCount,
} from '$lib/photo/queue';
import { uploadPhoto } from '$lib/photo/upload';
```

3. Update `init()` to initialize photo counts:
```typescript
this.pendingPhotoCount = await getPendingPhotoCount();
this.failedPhotoCount = await getFailedPhotoCount();
```

4. Add `processPhotoQueue()` method:
```typescript
async processPhotoQueue(): Promise<void> {
  const client = getConvexClient();
  if (!client || !connectionStatus.isOnline) return;

  const photos = await getPhotoQueue();
  this.pendingPhotoCount = photos.filter(p => p.uploadStatus !== 'failed').length;

  // Process sequentially (one at a time)
  for (const photo of photos) {
    if (photo.uploadStatus === 'failed') continue;

    this.currentPhotoUpload = photo.id;
    await markPhotoUploading(photo.id);

    try {
      await uploadPhoto(
        client,
        photo.blob,
        photo.dailyChoreClientId,
        photo.capturedAt,
        photo.capturedBy,
      );
      await removePhoto(photo.id);
      this.pendingPhotoCount = Math.max(0, this.pendingPhotoCount - 1);
    } catch (error) {
      const retryCount = await incrementPhotoRetry(photo.id);
      if (retryCount >= MAX_RETRIES) {
        await markPhotoFailed(photo.id);
        this.failedPhotoCount += 1;
        console.error(`[Sync] Photo ${photo.id} failed after ${MAX_RETRIES} retries`, error);
      } else {
        console.warn(`[Sync] Photo ${photo.id} failed, retry ${retryCount}/${MAX_RETRIES}`, error);
      }
    }
  }

  this.currentPhotoUpload = null;
}
```

5. Call `processPhotoQueue()` after `processQueue()` in `processQueue()` method (at the end before setting lastSyncedAt):
```typescript
// After mutation queue processing
await this.processPhotoQueue();
```

6. Add `retryFailedPhotos()` method:
```typescript
async retryFailedPhotos(): Promise<number> {
  const { resetFailedPhotos } = await import('$lib/photo/queue');
  const count = await resetFailedPhotos();
  this.failedPhotoCount = 0;
  await this.processPhotoQueue();
  return count;
}
```

Ensure photo queue is processed:
- On initial sync when online
- On periodic sync interval
- When coming back online
- When tab becomes visible
  </action>
  <verify>
Run `npm run build` - should compile without errors.
Run `npm run check` - TypeScript should pass.
Verify syncEngine has pendingPhotoCount, failedPhotoCount, currentPhotoUpload state.
Verify processPhotoQueue method exists.
  </verify>
  <done>
Sync engine processes photo queue after mutation queue.
Sequential photo uploads with progress tracking.
Retry logic matches mutation queue pattern (3 retries).
Reactive state for UI to show photo upload status.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. `npm run check` passes TypeScript validation
3. src/lib/photo/queue.ts exports all queue operations
4. src/lib/photo/upload.ts exports uploadPhoto and getPhotoViewUrl
5. src/lib/sync/engine.svelte.ts has pendingPhotoCount, failedPhotoCount state
6. src/lib/sync/engine.svelte.ts has processPhotoQueue method
7. Photo queue processing integrates with existing sync cycle
</verification>

<success_criteria>
- Photos can be queued for upload when offline
- Queued photos upload automatically when online
- Upload progress is visible via reactive state
- Failed uploads are retried up to 3 times
- Photo upload status integrates with existing sync UI
</success_criteria>

<output>
After completion, create `.planning/phases/05-photo-verification/05-03-SUMMARY.md`
</output>
