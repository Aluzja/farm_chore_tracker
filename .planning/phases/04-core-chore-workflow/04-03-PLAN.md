---
phase: 04-core-chore-workflow
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/lib/stores/dailyChores.svelte.ts
  - src/lib/db/operations.ts
  - src/lib/sync/engine.svelte.ts
  - src/routes/(app)/+page.svelte
  - src/routes/(app)/+layout.svelte
autonomous: true

must_haves:
  truths:
    - "Daily list is cloned from master on first access each day"
    - "Chores display organized by time-of-day (morning/afternoon/evening)"
    - "Within each time slot, chores are grouped by animal category"
    - "User can mark chore complete with one tap"
    - "Completion syncs to all users in real-time"
    - "User can undo a completion (toggle back)"
    - "Completion shows who completed and when"
  artifacts:
    - path: "src/lib/stores/dailyChores.svelte.ts"
      provides: "Reactive daily chore store with grouping"
      exports: ["dailyChoreStore"]
    - path: "src/lib/db/operations.ts"
      provides: "IndexedDB operations for daily chores"
      contains: "putDailyChore"
    - path: "src/routes/(app)/+page.svelte"
      provides: "Daily chore list UI for workers"
      min_lines: 100
  key_links:
    - from: "src/routes/(app)/+page.svelte"
      to: "src/lib/stores/dailyChores.svelte.ts"
      via: "import dailyChoreStore"
      pattern: "dailyChoreStore"
    - from: "src/lib/stores/dailyChores.svelte.ts"
      to: "src/lib/db/operations.ts"
      via: "putDailyChore for IndexedDB persistence"
      pattern: "putDailyChore"
    - from: "src/routes/(app)/+layout.svelte"
      to: "src/convex/dailyChores.ts"
      via: "useQuery for real-time subscription"
      pattern: "api\\.dailyChores\\.getOrCreateDailyList"
---

<objective>
Implement daily chore list generation, display with grouping, and completion toggle with real-time sync.

Purpose: Enable workers to see today's chores organized by time/category and mark them complete.
Output: Working daily chore list at the app root with real-time completion sync.
</objective>

<execution_context>
@/Users/mike.wojnarowski/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike.wojnarowski/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-core-chore-workflow/04-RESEARCH.md

# Prior plan outputs
@.planning/phases/04-core-chore-workflow/04-01-SUMMARY.md

# Existing patterns
@src/lib/stores/chores.svelte.ts
@src/lib/db/operations.ts
@src/lib/sync/engine.svelte.ts
@src/routes/(app)/+layout.svelte
@src/routes/(app)/+page.svelte
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create daily chore store with grouping and IndexedDB operations</name>
  <files>src/lib/stores/dailyChores.svelte.ts, src/lib/db/operations.ts</files>
  <action>
**Add to src/lib/db/operations.ts:**

Add operations for daily chores (similar to existing chore operations):
```typescript
import { DailyChoreSchema, type DailyChore } from './schema';

// Daily chore operations
export async function getDailyChore(id: string): Promise<DailyChore | undefined> {
  const db = await getDB();
  const chore = await db.get(STORES.dailyChores, id);
  return chore ? DailyChoreSchema.parse(chore) : undefined;
}

export async function getAllDailyChores(): Promise<DailyChore[]> {
  const db = await getDB();
  const chores = await db.getAll(STORES.dailyChores);
  return chores.map((c) => DailyChoreSchema.parse(c));
}

export async function getDailyChoresByDate(date: string): Promise<DailyChore[]> {
  const db = await getDB();
  const chores = await db.getAllFromIndex(STORES.dailyChores, 'by-date', date);
  return chores.map((c) => DailyChoreSchema.parse(c));
}

export async function putDailyChore(chore: DailyChore): Promise<void> {
  const validated = DailyChoreSchema.parse(chore);
  const db = await getDB();
  await db.put(STORES.dailyChores, validated);
}

export async function putDailyChores(chores: DailyChore[]): Promise<void> {
  const db = await getDB();
  const tx = db.transaction(STORES.dailyChores, 'readwrite');
  await Promise.all([...chores.map((c) => tx.store.put(DailyChoreSchema.parse(c))), tx.done]);
}

export async function deleteDailyChore(id: string): Promise<void> {
  const db = await getDB();
  await db.delete(STORES.dailyChores, id);
}
```

**Create src/lib/stores/dailyChores.svelte.ts:**

```typescript
import { browser } from '$app/environment';
import { getDailyChoresByDate, putDailyChore, putDailyChores } from '$lib/db/operations';
import { enqueueMutation } from '$lib/sync/queue';
import { getTodayDateString } from '$lib/utils/date';
import type { DailyChore } from '$lib/db/schema';

type TimeSlot = 'morning' | 'afternoon' | 'evening';

interface CategoryGroup {
  name: string;
  chores: DailyChore[];
}

interface TimeSlotGroup {
  timeSlot: TimeSlot;
  categories: CategoryGroup[];
}

class DailyChoreStore {
  items = $state<DailyChore[]>([]);
  isLoading = $state(true);
  error = $state<Error | null>(null);
  currentDate = $state(getTodayDateString());

  // Track pending deletes to prevent hydration conflicts
  private pendingDeletes = new Set<string>();

  // Grouped by time slot, then by animal category
  grouped = $derived.by(() => {
    const timeSlotOrder: TimeSlot[] = ['morning', 'afternoon', 'evening'];
    const result: TimeSlotGroup[] = [];

    for (const timeSlot of timeSlotOrder) {
      const slotChores = this.items.filter(c => c.timeSlot === timeSlot);
      if (slotChores.length === 0) continue;

      // Group by animal category
      const categoryMap = new Map<string, DailyChore[]>();
      for (const chore of slotChores) {
        const category = chore.animalCategory || 'General';
        if (!categoryMap.has(category)) {
          categoryMap.set(category, []);
        }
        categoryMap.get(category)!.push(chore);
      }

      // Sort categories alphabetically, chores by sortOrder
      const categories = Array.from(categoryMap.entries())
        .map(([name, chores]) => ({
          name,
          chores: chores.sort((a, b) => a.sortOrder - b.sortOrder),
        }))
        .sort((a, b) => a.name.localeCompare(b.name));

      result.push({ timeSlot, categories });
    }

    return result;
  });

  // Progress stats
  completedCount = $derived(this.items.filter(c => c.isCompleted).length);
  totalCount = $derived(this.items.length);
  progress = $derived(this.totalCount > 0 ? Math.round((this.completedCount / this.totalCount) * 100) : 0);

  // Load from IndexedDB for today
  async load(): Promise<void> {
    if (!browser) return;

    try {
      this.isLoading = true;
      this.error = null;
      this.currentDate = getTodayDateString();
      const chores = await getDailyChoresByDate(this.currentDate);
      this.items = chores;
    } catch (e) {
      this.error = e instanceof Error ? e : new Error(String(e));
      console.error('[DailyChoreStore] Load error:', e);
    } finally {
      this.isLoading = false;
    }
  }

  // Hydrate from Convex server data
  async hydrateFromServer(serverChores: Array<{
    _id: string;
    clientId: string;
    date: string;
    masterChoreId?: string;
    text: string;
    timeSlot: string;
    animalCategory: string;
    sortOrder: number;
    isCompleted: boolean;
    completedAt?: string;
    completedBy?: string;
    isAdHoc: boolean;
    lastModified: number;
  }>): Promise<void> {
    if (!browser) return;

    try {
      const today = getTodayDateString();
      // Only hydrate today's chores
      const todayChores = serverChores.filter(c => c.date === today);

      const serverMap = new Map<string, DailyChore>();
      for (const sc of todayChores) {
        if (this.pendingDeletes.has(sc.clientId)) continue;

        serverMap.set(sc.clientId, {
          _id: sc.clientId,
          date: sc.date,
          masterChoreId: sc.masterChoreId,
          text: sc.text,
          timeSlot: sc.timeSlot,
          animalCategory: sc.animalCategory,
          sortOrder: sc.sortOrder,
          isCompleted: sc.isCompleted,
          completedAt: sc.completedAt,
          completedBy: sc.completedBy,
          isAdHoc: sc.isAdHoc,
          syncStatus: 'synced' as const,
          lastModified: sc.lastModified,
        });
      }

      // Merge with local
      const localMap = new Map(this.items.map(c => [c._id, c]));
      let hasChanges = false;

      for (const [id, serverChore] of serverMap) {
        const local = localMap.get(id);
        if (!local) {
          localMap.set(id, serverChore);
          hasChanges = true;
        } else if (local.syncStatus === 'pending') {
          // Keep local pending changes
        } else if (serverChore.lastModified > local.lastModified) {
          localMap.set(id, serverChore);
          hasChanges = true;
        }
      }

      // Remove items deleted on server (if synced locally)
      for (const [id, local] of localMap) {
        if (!serverMap.has(id) && local.syncStatus === 'synced') {
          localMap.delete(id);
          hasChanges = true;
        }
      }

      if (!hasChanges) return;

      const merged = Array.from(localMap.values());
      await putDailyChores(merged);
      this.items = merged;
    } catch (e) {
      console.error('[DailyChoreStore] Hydration error:', e);
    }
  }

  // Toggle completion
  async toggleComplete(id: string, userName: string): Promise<void> {
    const chore = this.items.find(c => c._id === id);
    if (!chore) return;

    const now = Date.now();
    const nowIso = new Date(now).toISOString();
    const updated: DailyChore = {
      ...chore,
      isCompleted: !chore.isCompleted,
      completedAt: !chore.isCompleted ? nowIso : undefined,
      completedBy: !chore.isCompleted ? userName : undefined,
      syncStatus: 'pending',
      lastModified: now,
    };

    // Optimistic update
    this.items = this.items.map(c => c._id === id ? updated : c);

    // Persist to IndexedDB
    await putDailyChore($state.snapshot(updated));

    // Queue for sync
    await enqueueMutation('update', 'dailyChores', {
      id: updated._id,
      isCompleted: updated.isCompleted,
      completedAt: updated.completedAt,
      completedBy: updated.completedBy,
      lastModified: updated.lastModified,
    });
  }

  // Mark item as synced
  markSynced(id: string): void {
    const index = this.items.findIndex(c => c._id === id);
    if (index !== -1 && this.items[index].syncStatus !== 'synced') {
      this.items[index] = { ...this.items[index], syncStatus: 'synced' };
    }
  }
}

export const dailyChoreStore = new DailyChoreStore();
```
  </action>
  <verify>Run `bun run check` to verify no TypeScript errors</verify>
  <done>DailyChoreStore implemented with grouping, hydration, and optimistic toggle</done>
</task>

<task type="auto">
  <name>Task 2: Update sync engine to handle daily chores</name>
  <files>src/lib/sync/engine.svelte.ts</files>
  <action>
Update the sync engine's applyMutation method to handle dailyChores table mutations:

In the switch statement for `table`, add a case for 'dailyChores':

```typescript
case 'dailyChores': {
  switch (type) {
    case 'create': {
      const createId = payload.clientId as string;
      await client.mutation(api.dailyChores.addAdHoc, payload as {
        clientId: string;
        text: string;
        timeSlot: string;
        animalCategory: string;
        createdBy?: string;
        lastModified: number;
      });
      await this.markDailyChoreLocalSynced(createId);
      const { dailyChoreStore } = await import('$lib/stores/dailyChores.svelte');
      dailyChoreStore.markSynced(createId);
      break;
    }
    case 'update': {
      const updateId = payload.id as string;
      await client.mutation(api.dailyChores.toggleComplete, payload as {
        id: string;
        isCompleted: boolean;
        completedAt?: string;
        completedBy?: string;
        lastModified: number;
      });
      await this.markDailyChoreLocalSynced(updateId);
      const { dailyChoreStore } = await import('$lib/stores/dailyChores.svelte');
      dailyChoreStore.markSynced(updateId);
      break;
    }
    default:
      throw new Error(`Unsupported dailyChores mutation type: ${type}`);
  }
  break;
}
```

Add helper method:
```typescript
private async markDailyChoreLocalSynced(id: string): Promise<void> {
  const { getDailyChore, putDailyChore } = await import('$lib/db/operations');
  const chore = await getDailyChore(id);
  if (chore) {
    await putDailyChore({ ...chore, syncStatus: 'synced' });
  }
}
```

Import api at top if not already: `import { api } from '../../convex/_generated/api';`
  </action>
  <verify>Run `bun run build` to verify no TypeScript errors</verify>
  <done>Sync engine handles dailyChores create and update mutations</done>
</task>

<task type="auto">
  <name>Task 3: Update app layout and page for daily chores</name>
  <files>src/routes/(app)/+layout.svelte, src/routes/(app)/+page.svelte</files>
  <action>
**Update src/routes/(app)/+layout.svelte:**

1. Import dailyChoreStore alongside choreStore
2. Subscribe to `api.dailyChores.getOrCreateDailyList` instead of (or in addition to) api.chores.list
3. Handle the clone-on-first-access pattern:

```typescript
import { dailyChoreStore } from '$lib/stores/dailyChores.svelte';

// Add daily chores subscription
const dailyChoresQuery = browser ? useQuery(api.dailyChores.getOrCreateDailyList, {}) : null;

// Handle clone trigger
$effect(() => {
  if (dailyChoresQuery?.data && 'needsClone' in dailyChoresQuery.data && convexClient) {
    // Trigger clone mutation
    convexClient.mutation(api.dailyChores.cloneMasterToDaily, {
      date: dailyChoresQuery.data.date
    });
  }
});

// Hydrate daily store when data is array
$effect(() => {
  if (browser && hasAccess && dailyChoresQuery?.data && Array.isArray(dailyChoresQuery.data) && connectionStatus.isOnline) {
    dailyChoreStore.hydrateFromServer(dailyChoresQuery.data);
  }
});

// Also load from IndexedDB in initializeApp
async function initializeApp() {
  if (isInitialized) return;
  isInitialized = true;
  await choreStore.load();
  await dailyChoreStore.load(); // Add this
  await syncEngine.init();
}
```

**Replace src/routes/(app)/+page.svelte content:**

Create a clean daily chore list UI:

```svelte
<script lang="ts">
  import { dailyChoreStore } from '$lib/stores/dailyChores.svelte';
  import { syncEngine } from '$lib/sync/engine.svelte';
  import { connectionStatus } from '$lib/sync/status.svelte';
  import { formatTimeSlot } from '$lib/utils/date';
  import { page } from '$app/stores';

  // Get user name from layout context or access key
  // For now, use a simple prop or derive from context
  let userName = 'Worker'; // Will be enhanced in later task

  async function handleToggle(id: string) {
    await dailyChoreStore.toggleComplete(id, userName);
  }

  function formatCompletionTime(isoString?: string): string {
    if (!isoString) return '';
    const date = new Date(isoString);
    return date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
  }
</script>

<main class="container">
  <header class="app-header">
    <h1>Today's Chores</h1>
    <div class="progress-bar">
      <div class="progress-fill" style="width: {dailyChoreStore.progress}%"></div>
    </div>
    <p class="progress-text">{dailyChoreStore.completedCount}/{dailyChoreStore.totalCount} complete</p>
  </header>

  <!-- Connection status indicator -->
  <div class="status-indicator" class:online={connectionStatus.isOnline} class:offline={!connectionStatus.isOnline}>
    {connectionStatus.isOnline ? 'Online' : 'Offline'}
    {#if syncEngine.pendingCount > 0}
      <span class="pending-badge">{syncEngine.pendingCount} pending</span>
    {/if}
  </div>

  {#if dailyChoreStore.isLoading}
    <div class="loading">Loading chores...</div>
  {:else if dailyChoreStore.error}
    <div class="error">Error: {dailyChoreStore.error.message}</div>
  {:else if dailyChoreStore.items.length === 0}
    <div class="empty">
      <p>No chores for today yet.</p>
      <p class="hint">Chores will appear once the admin sets up the master list.</p>
    </div>
  {:else}
    {#each dailyChoreStore.grouped as group}
      <section class="time-slot">
        <h2 class="time-slot-header">{formatTimeSlot(group.timeSlot)}</h2>

        {#each group.categories as category}
          <div class="animal-category">
            <h3 class="category-header">{category.name}</h3>

            <ul class="chore-list">
              {#each category.chores as chore (chore._id)}
                <li class="chore-item" class:completed={chore.isCompleted}>
                  <button
                    class="toggle-btn"
                    onclick={() => handleToggle(chore._id)}
                    aria-label={chore.isCompleted ? 'Mark incomplete' : 'Mark complete'}
                  >
                    {#if chore.isCompleted}
                      <span class="checkmark">&#10003;</span>
                    {:else}
                      <span class="circle"></span>
                    {/if}
                  </button>

                  <div class="chore-content">
                    <span class="chore-text">{chore.text}</span>
                    {#if chore.isCompleted && chore.completedBy}
                      <span class="completion-info">
                        {chore.completedBy} at {formatCompletionTime(chore.completedAt)}
                      </span>
                    {/if}
                  </div>

                  {#if chore.isAdHoc}
                    <span class="adhoc-badge">Today only</span>
                  {/if}

                  {#if chore.syncStatus === 'pending'}
                    <span class="sync-indicator pending">...</span>
                  {:else if chore.syncStatus === 'failed'}
                    <span class="sync-indicator failed">!</span>
                  {/if}
                </li>
              {/each}
            </ul>
          </div>
        {/each}
      </section>
    {/each}
  {/if}
</main>

<style>
  .container {
    max-width: 600px;
    margin: 0 auto;
    padding: 1rem;
    font-family: system-ui, -apple-system, sans-serif;
  }

  .app-header {
    margin-bottom: 1.5rem;
    text-align: center;
  }

  .app-header h1 {
    font-size: 1.5rem;
    color: #2d5016;
    margin: 0 0 0.75rem 0;
  }

  .progress-bar {
    height: 8px;
    background: #e0e0e0;
    border-radius: 4px;
    overflow: hidden;
    margin-bottom: 0.5rem;
  }

  .progress-fill {
    height: 100%;
    background: #4caf50;
    transition: width 0.3s ease;
  }

  .progress-text {
    font-size: 0.875rem;
    color: #666;
    margin: 0;
  }

  .status-indicator {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem;
    border-radius: 4px;
    font-size: 0.75rem;
    margin-bottom: 1rem;
  }

  .status-indicator.online {
    background: #e8f5e9;
    color: #2e7d32;
  }

  .status-indicator.offline {
    background: #fff3e0;
    color: #e65100;
  }

  .pending-badge {
    background: #fff;
    padding: 0.125rem 0.375rem;
    border-radius: 3px;
  }

  .loading, .error, .empty {
    text-align: center;
    padding: 3rem 1rem;
    color: #666;
  }

  .error {
    color: #c62828;
  }

  .hint {
    font-size: 0.875rem;
    color: #999;
    margin-top: 0.5rem;
  }

  .time-slot {
    margin-bottom: 1.5rem;
  }

  .time-slot-header {
    font-size: 1.125rem;
    color: #333;
    margin: 0 0 0.75rem 0;
    padding-bottom: 0.5rem;
    border-bottom: 2px solid #4caf50;
  }

  .animal-category {
    margin-bottom: 1rem;
  }

  .category-header {
    font-size: 0.875rem;
    color: #666;
    margin: 0 0 0.5rem 0;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .chore-list {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .chore-item {
    display: flex;
    align-items: flex-start;
    gap: 0.75rem;
    padding: 0.75rem;
    background: #fff;
    border-radius: 8px;
    margin-bottom: 0.5rem;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    transition: background-color 0.2s;
  }

  .chore-item.completed {
    background: #f5f5f5;
  }

  .toggle-btn {
    flex-shrink: 0;
    width: 2.5rem;
    height: 2.5rem;
    border-radius: 50%;
    border: 2px solid #4caf50;
    background: #fff;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.25rem;
    padding: 0;
    transition: all 0.2s;
  }

  .toggle-btn:active {
    transform: scale(0.95);
  }

  .chore-item.completed .toggle-btn {
    background: #4caf50;
    color: #fff;
  }

  .circle {
    display: block;
    width: 1rem;
    height: 1rem;
    border-radius: 50%;
    border: 2px solid #ccc;
  }

  .checkmark {
    font-weight: bold;
  }

  .chore-content {
    flex: 1;
    min-width: 0;
  }

  .chore-text {
    display: block;
    word-wrap: break-word;
  }

  .chore-item.completed .chore-text {
    text-decoration: line-through;
    color: #999;
  }

  .completion-info {
    display: block;
    font-size: 0.75rem;
    color: #888;
    margin-top: 0.25rem;
  }

  .adhoc-badge {
    flex-shrink: 0;
    font-size: 0.625rem;
    padding: 0.125rem 0.375rem;
    background: #e3f2fd;
    color: #1565c0;
    border-radius: 3px;
    text-transform: uppercase;
  }

  .sync-indicator {
    flex-shrink: 0;
    font-size: 0.875rem;
  }

  .sync-indicator.pending {
    color: #888;
  }

  .sync-indicator.failed {
    color: #f44336;
    font-weight: bold;
  }
</style>
```
  </action>
  <verify>Run `bun run build` to verify no errors. Start dev server, access app with valid key, verify daily chores display.</verify>
  <done>Daily chore list displays with grouping; completion toggle works with optimistic updates and real-time sync</done>
</task>

</tasks>

<verification>
1. `bun run build` completes without errors
2. Access app with valid access key
3. If master chores exist, daily list is cloned automatically
4. Chores appear grouped by time slot, then by animal category
5. Tap chore to toggle completion - updates instantly
6. Completion shows user name and time
7. Open in another browser/tab - see completion sync in real-time
8. Go offline, toggle chore, go online - syncs correctly
</verification>

<success_criteria>
- Daily list auto-clones from master on first access each day
- Time slot groups display in order: Morning, Afternoon, Evening
- Animal categories appear alphabetically within each time slot
- One-tap completion with immediate visual feedback
- Completion attribution shows "Name at HH:MM"
- Real-time sync across multiple users/tabs
- Undo (toggle back) works correctly
- Offline changes queue and sync when online
</success_criteria>

<output>
After completion, create `.planning/phases/04-core-chore-workflow/04-03-SUMMARY.md`
</output>
