---
phase: 03-auth-and-access
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/convex/accessKeys.ts
  - src/convex/users.ts
  - src/lib/auth/access-key.ts
  - src/lib/auth/admin.svelte.ts
autonomous: true

must_haves:
  truths:
    - "Admin can create access keys via Convex mutation"
    - "Admin can revoke access keys"
    - "Access keys can be validated without full auth"
    - "Validation result is cached in localStorage for offline use"
  artifacts:
    - path: "src/convex/accessKeys.ts"
      provides: "Access key CRUD mutations"
      exports: ["create", "revoke", "list", "validate"]
    - path: "src/convex/users.ts"
      provides: "User queries including isAdmin check"
      exports: ["currentUser", "isCurrentUserAdmin"]
    - path: "src/lib/auth/access-key.ts"
      provides: "Client-side access key validation and storage"
      exports: ["getStoredAccessKey", "storeAccessKey", "clearAccessKey", "validateAccessKey", "getCachedValidation"]
    - path: "src/lib/auth/admin.svelte.ts"
      provides: "Admin auth state with Svelte 5 runes"
      exports: ["adminAuth"]
  key_links:
    - from: "src/lib/auth/access-key.ts"
      to: "src/convex/accessKeys.ts"
      via: "validate query call"
      pattern: "api\\.accessKeys\\.validate"
    - from: "src/lib/auth/admin.svelte.ts"
      to: "src/convex/auth.ts"
      via: "signIn/signOut mutations"
      pattern: "api\\.auth\\.signIn"
---

<objective>
Create Convex APIs for access key management and client-side auth utilities

Purpose: Build the business logic layer for both admin authentication and access key validation. This enables the UI layer (Plan 03) to implement login and key management features.

Output:
- Convex mutations for access key CRUD (create, revoke, list, validate)
- User queries with admin detection
- Client-side access key utilities with localStorage caching
- Admin auth state management with Svelte 5 runes
</objective>

<execution_context>
@/Users/mike.wojnarowski/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike.wojnarowski/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-auth-and-access/03-RESEARCH.md

# Reference previous plan summary for schema
@.planning/phases/03-auth-and-access/03-01-SUMMARY.md

# Existing sync engine pattern for Convex client access
@src/lib/sync/engine.svelte.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Convex user queries with admin detection</name>
  <files>src/convex/users.ts</files>
  <action>
Create user-related queries including admin detection:

```typescript
import { v } from "convex/values";
import { query, mutation } from "./_generated/server";
import { getAuthUserId } from "@convex-dev/auth/server";

// Get the currently authenticated user
export const currentUser = query({
  args: {},
  handler: async (ctx) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) return null;
    return await ctx.db.get(userId);
  },
});

// Check if current user is admin
export const isCurrentUserAdmin = query({
  args: {},
  handler: async (ctx) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) return false;
    const user = await ctx.db.get(userId);
    return user?.isAdmin ?? false;
  },
});

// Make user admin (internal use, called after first signup)
export const makeAdmin = mutation({
  args: { userId: v.id("users") },
  handler: async (ctx, { userId }) => {
    // Check if any admins exist
    const existingAdmins = await ctx.db
      .query("users")
      .filter((q) => q.eq(q.field("isAdmin"), true))
      .first();

    if (existingAdmins) {
      throw new Error("Admin already exists. Use admin console to grant admin rights.");
    }

    await ctx.db.patch(userId, { isAdmin: true });
    return { success: true };
  },
});

// Called after signup to check/assign first-user admin status
export const checkFirstUserAdmin = mutation({
  args: {},
  handler: async (ctx) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) throw new Error("Not authenticated");

    // Check if any admins exist
    const existingAdmin = await ctx.db
      .query("users")
      .filter((q) => q.eq(q.field("isAdmin"), true))
      .first();

    // If no admin exists, make this user admin
    if (!existingAdmin) {
      await ctx.db.patch(userId, { isAdmin: true });
      return { madeAdmin: true };
    }

    return { madeAdmin: false };
  },
});
```

This follows the "first user is admin" pattern from research.
  </action>
  <verify>
`bunx convex dev --once` deploys without errors.
Check api.d.ts includes users.currentUser, users.isCurrentUserAdmin, users.checkFirstUserAdmin.
  </verify>
  <done>User queries created with admin detection and first-user-admin mutation</done>
</task>

<task type="auto">
  <name>Task 2: Create access key Convex mutations</name>
  <files>src/convex/accessKeys.ts</files>
  <action>
Create access key CRUD operations:

```typescript
import { v } from "convex/values";
import { mutation, query } from "./_generated/server";
import { getAuthUserId } from "@convex-dev/auth/server";

// Validate an access key (no auth required - this IS the auth check for workers)
export const validate = query({
  args: { key: v.string() },
  handler: async (ctx, { key }) => {
    const accessKey = await ctx.db
      .query("accessKeys")
      .withIndex("by_key", (q) => q.eq("key", key))
      .first();

    if (!accessKey) {
      return { valid: false, reason: "not_found" as const };
    }

    if (accessKey.revokedAt) {
      return { valid: false, reason: "revoked" as const };
    }

    return {
      valid: true,
      displayName: accessKey.displayName,
      keyId: accessKey._id,
    };
  },
});

// Record key usage (called when access key is used)
export const recordUsage = mutation({
  args: { key: v.string() },
  handler: async (ctx, { key }) => {
    const accessKey = await ctx.db
      .query("accessKeys")
      .withIndex("by_key", (q) => q.eq("key", key))
      .first();

    if (accessKey && !accessKey.revokedAt) {
      await ctx.db.patch(accessKey._id, { lastUsedAt: Date.now() });
    }
  },
});

// Create a new access key (admin only)
export const create = mutation({
  args: { displayName: v.string() },
  handler: async (ctx, { displayName }) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) throw new Error("Not authenticated");

    const user = await ctx.db.get(userId);
    if (!user?.isAdmin) throw new Error("Admin access required");

    // Generate secure random key (16 chars, alphanumeric)
    const chars = "abcdefghijklmnopqrstuvwxyz0123456789";
    let key = "";
    for (let i = 0; i < 16; i++) {
      key += chars.charAt(Math.floor(Math.random() * chars.length));
    }

    const id = await ctx.db.insert("accessKeys", {
      key,
      displayName,
      createdAt: Date.now(),
      createdBy: userId,
    });

    return { id, key };
  },
});

// Revoke an access key (admin only)
export const revoke = mutation({
  args: { id: v.id("accessKeys") },
  handler: async (ctx, { id }) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) throw new Error("Not authenticated");

    const user = await ctx.db.get(userId);
    if (!user?.isAdmin) throw new Error("Admin access required");

    const accessKey = await ctx.db.get(id);
    if (!accessKey) throw new Error("Access key not found");

    await ctx.db.patch(id, { revokedAt: Date.now() });
    return { success: true };
  },
});

// List all access keys (admin only)
export const list = query({
  args: {},
  handler: async (ctx) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) return [];

    const user = await ctx.db.get(userId);
    if (!user?.isAdmin) return [];

    const keys = await ctx.db.query("accessKeys").collect();
    // Don't expose the actual key in list, only in create response
    return keys.map((k) => ({
      id: k._id,
      displayName: k.displayName,
      createdAt: k.createdAt,
      revokedAt: k.revokedAt,
      lastUsedAt: k.lastUsedAt,
      isRevoked: !!k.revokedAt,
    }));
  },
});
```

IMPORTANT: The `validate` query does NOT require authentication - that's the whole point. Workers use the access key AS their authentication.
  </action>
  <verify>
`bunx convex dev --once` deploys without errors.
Check api.d.ts includes accessKeys.validate, accessKeys.create, accessKeys.revoke, accessKeys.list.
  </verify>
  <done>Access key CRUD mutations created with admin-only create/revoke and public validate</done>
</task>

<task type="auto">
  <name>Task 3: Create client-side auth utilities</name>
  <files>
src/lib/auth/access-key.ts
src/lib/auth/admin.svelte.ts
  </files>
  <action>
Create two client-side auth modules:

**src/lib/auth/access-key.ts** - Access key validation with localStorage caching:

```typescript
import { browser } from '$app/environment';
import { getConvexClient } from '$lib/sync/engine.svelte';
import { api } from '../../convex/_generated/api';

const ACCESS_KEY_STORAGE = 'kitchen_sink_access_key';
const VALIDATION_CACHE_STORAGE = 'kitchen_sink_key_validation';
const CACHE_DURATION_MS = 24 * 60 * 60 * 1000; // 24 hours

interface ValidationCache {
  valid: boolean;
  displayName?: string;
  validatedAt: number;
}

// Get stored access key from localStorage
export function getStoredAccessKey(): string | null {
  if (!browser) return null;
  return localStorage.getItem(ACCESS_KEY_STORAGE);
}

// Store access key in localStorage
export function storeAccessKey(key: string): void {
  if (!browser) return;
  localStorage.setItem(ACCESS_KEY_STORAGE, key);
}

// Clear stored access key
export function clearAccessKey(): void {
  if (!browser) return;
  localStorage.removeItem(ACCESS_KEY_STORAGE);
  localStorage.removeItem(VALIDATION_CACHE_STORAGE);
}

// Get cached validation result (for offline use)
export function getCachedValidation(): ValidationCache | null {
  if (!browser) return null;
  const cached = localStorage.getItem(VALIDATION_CACHE_STORAGE);
  if (!cached) return null;

  try {
    const parsed = JSON.parse(cached) as ValidationCache;
    // Check if cache is still valid
    if (Date.now() - parsed.validatedAt < CACHE_DURATION_MS) {
      return parsed;
    }
    // Cache expired
    localStorage.removeItem(VALIDATION_CACHE_STORAGE);
    return null;
  } catch {
    return null;
  }
}

// Cache validation result
function cacheValidation(valid: boolean, displayName?: string): void {
  if (!browser) return;
  const cache: ValidationCache = {
    valid,
    displayName,
    validatedAt: Date.now(),
  };
  localStorage.setItem(VALIDATION_CACHE_STORAGE, JSON.stringify(cache));
}

// Validate access key against Convex
export async function validateAccessKey(key: string): Promise<{
  valid: boolean;
  reason?: 'not_found' | 'revoked';
  displayName?: string;
}> {
  const client = getConvexClient();
  if (!client) {
    // Offline - check cache
    const cached = getCachedValidation();
    if (cached) {
      return { valid: cached.valid, displayName: cached.displayName };
    }
    // No cache, can't validate
    return { valid: false, reason: 'not_found' };
  }

  try {
    const result = await client.query(api.accessKeys.validate, { key });

    // Cache the result
    cacheValidation(result.valid, result.valid ? result.displayName : undefined);

    // Record usage if valid
    if (result.valid) {
      // Fire and forget - don't await
      client.mutation(api.accessKeys.recordUsage, { key }).catch(() => {
        // Ignore errors recording usage
      });
    }

    return result;
  } catch (error) {
    // Network error - check cache
    const cached = getCachedValidation();
    if (cached) {
      return { valid: cached.valid, displayName: cached.displayName };
    }
    return { valid: false, reason: 'not_found' };
  }
}

// Extract key from URL and clean up
export function extractKeyFromUrl(url: URL): string | null {
  const key = url.searchParams.get('key');
  return key;
}
```

**src/lib/auth/admin.svelte.ts** - Admin auth state with Svelte 5 runes:

```typescript
import { browser } from '$app/environment';
import { getConvexClient } from '$lib/sync/engine.svelte';
import { api } from '../../convex/_generated/api';

type AuthState = 'loading' | 'authenticated' | 'unauthenticated';

class AdminAuth {
  state = $state<AuthState>('loading');
  userId = $state<string | null>(null);
  isAdmin = $state(false);
  error = $state<string | null>(null);

  get isAuthenticated() {
    return this.state === 'authenticated';
  }

  get isLoading() {
    return this.state === 'loading';
  }

  async checkAuth(): Promise<void> {
    if (!browser) return;

    const client = getConvexClient();
    if (!client) {
      this.state = 'unauthenticated';
      return;
    }

    try {
      const user = await client.query(api.users.currentUser, {});
      if (user) {
        this.userId = user._id;
        this.isAdmin = user.isAdmin ?? false;
        this.state = 'authenticated';
      } else {
        this.state = 'unauthenticated';
        this.userId = null;
        this.isAdmin = false;
      }
    } catch (error) {
      console.error('[AdminAuth] Check failed:', error);
      this.state = 'unauthenticated';
      this.error = error instanceof Error ? error.message : 'Auth check failed';
    }
  }

  async signIn(email: string, password: string): Promise<{ success: boolean; error?: string }> {
    if (!browser) return { success: false, error: 'Not in browser' };

    const client = getConvexClient();
    if (!client) return { success: false, error: 'Convex client not available' };

    this.error = null;

    try {
      // Call Convex Auth signIn mutation
      await client.mutation(api.auth.signIn, {
        provider: 'password',
        params: { email, password, flow: 'signIn' },
      });

      // Check if first user (auto-admin)
      await client.mutation(api.users.checkFirstUserAdmin, {});

      // Refresh auth state
      await this.checkAuth();
      return { success: true };
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Sign in failed';
      this.error = message;
      return { success: false, error: message };
    }
  }

  async signUp(email: string, password: string): Promise<{ success: boolean; error?: string }> {
    if (!browser) return { success: false, error: 'Not in browser' };

    const client = getConvexClient();
    if (!client) return { success: false, error: 'Convex client not available' };

    this.error = null;

    try {
      // Call Convex Auth signIn mutation with signUp flow
      await client.mutation(api.auth.signIn, {
        provider: 'password',
        params: { email, password, flow: 'signUp' },
      });

      // Check if first user (auto-admin)
      await client.mutation(api.users.checkFirstUserAdmin, {});

      // Refresh auth state
      await this.checkAuth();
      return { success: true };
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Sign up failed';
      this.error = message;
      return { success: false, error: message };
    }
  }

  async signOut(): Promise<void> {
    if (!browser) return;

    const client = getConvexClient();
    if (!client) return;

    try {
      await client.mutation(api.auth.signOut, {});
    } catch (error) {
      console.error('[AdminAuth] Sign out error:', error);
    } finally {
      this.state = 'unauthenticated';
      this.userId = null;
      this.isAdmin = false;
    }
  }
}

export const adminAuth = new AdminAuth();
```

IMPORTANT:
- Access key validation uses localStorage caching for offline resilience
- Admin auth uses Svelte 5 $state runes for reactivity
- Both modules use the global Convex client from sync engine
  </action>
  <verify>
`bun run check` passes (or shows only pre-existing type errors).
Files exist at:
- src/lib/auth/access-key.ts
- src/lib/auth/admin.svelte.ts
  </verify>
  <done>Client-side auth utilities created with localStorage caching and Svelte 5 reactive state</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `bunx convex dev --once` deploys all mutations/queries
2. `bun run build` completes without new errors
3. API types include:
   - api.users.currentUser
   - api.users.isCurrentUserAdmin
   - api.accessKeys.validate
   - api.accessKeys.create
   - api.accessKeys.revoke
   - api.accessKeys.list
4. Client auth utilities properly import from Convex API
</verification>

<success_criteria>
- Convex user queries work (currentUser, isCurrentUserAdmin, checkFirstUserAdmin)
- Convex access key mutations work (create, revoke, list, validate, recordUsage)
- Access key validation caches result in localStorage for 24 hours
- Admin auth state uses Svelte 5 runes
- Both modules integrate with global Convex client from sync engine
</success_criteria>

<output>
After completion, create `.planning/phases/03-auth-and-access/03-02-SUMMARY.md`
</output>
