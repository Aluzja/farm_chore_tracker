---
phase: 03-auth-and-access
plan: 04
type: execute
wave: 4
depends_on: ["03-02", "03-03"]
files_modified:
  - src/routes/(app)/+layout.svelte
  - src/routes/(app)/+layout.ts
  - src/routes/(app)/+page.svelte
  - src/routes/+layout.svelte
  - src/routes/+page.svelte
autonomous: false

must_haves:
  truths:
    - "User with valid URL key gains access without login"
    - "Invalid or revoked keys are rejected with clear feedback"
    - "Access key is extracted from URL and stored in localStorage"
    - "URL is cleaned after key extraction"
    - "Cached validation allows offline access"
  artifacts:
    - path: "src/routes/(app)/+layout.svelte"
      provides: "Public app layout with access key validation"
      contains: ["validateAccessKey", "storeAccessKey"]
    - path: "src/routes/(app)/+page.svelte"
      provides: "Main app page (moved from root)"
      contains: "choreStore"
  key_links:
    - from: "src/routes/(app)/+layout.svelte"
      to: "src/lib/auth/access-key.ts"
      via: "validateAccessKey and localStorage"
      pattern: "validateAccessKey|getStoredAccessKey"
    - from: "src/routes/+layout.svelte"
      to: "src/routes/(app)/+layout.svelte"
      via: "route nesting"
      pattern: "children"
---

<objective>
Implement route protection with access key validation for workers

Purpose: Complete the auth system by protecting the main app routes with access key validation. Workers access the app via shareable URL keys, which are validated and cached for offline use.

Output:
- App routes moved to (app) route group with access key protection
- Access key validation on entry with localStorage caching
- Clean URL after key extraction (remove ?key= from URL bar)
- Clear error messages for invalid/revoked keys
- Offline access via cached validation
</objective>

<execution_context>
@/Users/mike.wojnarowski/.claude/get-shit-done/workflows/execute-plan.md
@/Users/mike.wojnarowski/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-auth-and-access/03-RESEARCH.md

# Reference previous plan summaries
@.planning/phases/03-auth-and-access/03-02-SUMMARY.md
@.planning/phases/03-auth-and-access/03-03-SUMMARY.md

# Current root layout and page
@src/routes/+layout.svelte
@src/routes/+page.svelte
</context>

<tasks>

<task type="auto">
  <name>Task 1: Reorganize routes with (app) group and access validation</name>
  <files>
src/routes/(app)/+layout.svelte
src/routes/(app)/+layout.ts
src/routes/(app)/+page.svelte
src/routes/+page.svelte
  </files>
  <action>
Create a route group `(app)` for protected app routes and move the main page there.

**Step 1: Create route group layout**

Create **src/routes/(app)/+layout.ts:**
```typescript
// Disable SSR for app routes
export const ssr = false;
```

Create **src/routes/(app)/+layout.svelte:**
```svelte
<script lang="ts">
  import { onMount } from 'svelte';
  import { goto } from '$app/navigation';
  import { page } from '$app/stores';
  import { browser } from '$app/environment';
  import {
    getStoredAccessKey,
    storeAccessKey,
    clearAccessKey,
    validateAccessKey,
    getCachedValidation,
    extractKeyFromUrl
  } from '$lib/auth/access-key';
  import { adminAuth } from '$lib/auth/admin.svelte';
  import { connectionStatus } from '$lib/sync/status.svelte';

  let { children } = $props();

  let hasAccess = $state(false);
  let isValidating = $state(true);
  let error = $state<string | null>(null);
  let userName = $state<string | null>(null);

  onMount(async () => {
    // Check for key in URL first
    const urlKey = extractKeyFromUrl($page.url);
    if (urlKey) {
      // Clean URL immediately (remove ?key= from address bar)
      const cleanUrl = new URL($page.url);
      cleanUrl.searchParams.delete('key');
      window.history.replaceState({}, '', cleanUrl.toString());

      // Validate the URL key
      const result = await validateAccessKey(urlKey);
      if (result.valid) {
        storeAccessKey(urlKey);
        hasAccess = true;
        userName = result.displayName ?? null;
        isValidating = false;
        return;
      } else {
        error = result.reason === 'revoked'
          ? 'This access key has been revoked. Please contact the admin for a new key.'
          : 'Invalid access key. Please check the link or contact the admin.';
        isValidating = false;
        return;
      }
    }

    // Check stored key
    const storedKey = getStoredAccessKey();
    if (storedKey) {
      // Try online validation first
      if (connectionStatus.isOnline) {
        const result = await validateAccessKey(storedKey);
        if (result.valid) {
          hasAccess = true;
          userName = result.displayName ?? null;
          isValidating = false;
          return;
        } else {
          // Key was revoked or invalid
          clearAccessKey();
          error = result.reason === 'revoked'
            ? 'Your access key has been revoked. Please contact the admin for a new key.'
            : 'Your access key is no longer valid. Please request a new one.';
          isValidating = false;
          return;
        }
      } else {
        // Offline - use cached validation
        const cached = getCachedValidation();
        if (cached?.valid) {
          hasAccess = true;
          userName = cached.displayName ?? null;
          isValidating = false;
          return;
        }
        // No valid cache, but we have a key - allow access (will revalidate online)
        hasAccess = true;
        isValidating = false;
        return;
      }
    }

    // Check admin auth as fallback
    await adminAuth.checkAuth();
    if (adminAuth.isAuthenticated) {
      hasAccess = true;
      userName = 'Admin';
      isValidating = false;
      return;
    }

    // No access - show error
    error = 'No access key found. Please use a link shared by the admin.';
    isValidating = false;
  });

  function handleRequestAccess() {
    // Could open a modal or redirect to a request page
    // For now, just show info about getting access
    alert('Please contact the farm administrator for an access key.');
  }
</script>

{#if isValidating}
  <div class="min-h-screen flex items-center justify-center bg-gray-50">
    <div class="text-center">
      <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto"></div>
      <p class="mt-4 text-gray-600">Checking access...</p>
    </div>
  </div>
{:else if hasAccess}
  <!-- Show user name in header if available -->
  {#if userName}
    <div class="fixed top-2 right-2 text-xs text-gray-500 bg-white/80 px-2 py-1 rounded shadow-sm z-50">
      {userName}
    </div>
  {/if}
  {@render children?.()}
{:else}
  <div class="min-h-screen flex items-center justify-center bg-gray-50 px-4">
    <div class="max-w-md w-full text-center">
      <div class="bg-white rounded-lg shadow-md p-8">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 mx-auto text-gray-400 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
        </svg>
        <h1 class="text-xl font-semibold text-gray-900 mb-2">Access Required</h1>
        <p class="text-gray-600 mb-6">
          {error ?? 'You need an access key to use this app.'}
        </p>
        <div class="space-y-3">
          <button
            onclick={handleRequestAccess}
            class="w-full py-2 px-4 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors"
          >
            Request Access
          </button>
          <a
            href="/admin/login"
            class="block w-full py-2 px-4 border border-gray-300 text-gray-700 rounded-md hover:bg-gray-50 transition-colors"
          >
            Admin Login
          </a>
        </div>
      </div>
    </div>
  </div>
{/if}
```

**Step 2: Move main page to app group**

Move the current src/routes/+page.svelte content to **src/routes/(app)/+page.svelte**.

Keep the same content as the current +page.svelte (the chore test UI from Phase 2).

**Step 3: Create landing redirect at root**

Replace **src/routes/+page.svelte** with a simple redirect:

```svelte
<script lang="ts">
  import { onMount } from 'svelte';
  import { goto } from '$app/navigation';
  import { browser } from '$app/environment';
  import { page } from '$app/stores';
  import { getStoredAccessKey, extractKeyFromUrl } from '$lib/auth/access-key';

  onMount(() => {
    // If there's a key in URL or stored, redirect to app
    const urlKey = extractKeyFromUrl($page.url);
    const storedKey = getStoredAccessKey();

    if (urlKey || storedKey) {
      // Preserve the key param if present
      goto(urlKey ? `/?key=${urlKey}` : '/', { replaceState: true });
    }
  });
</script>

<svelte:head>
  <title>Kitchen Sink Farm</title>
</svelte:head>

<div class="min-h-screen flex items-center justify-center bg-gray-50 px-4">
  <div class="max-w-md w-full text-center">
    <h1 class="text-2xl font-bold text-gray-900 mb-4">Kitchen Sink Farm</h1>
    <p class="text-gray-600 mb-8">
      Farm chore tracking for the whole team.
    </p>
    <div class="space-y-3">
      <a
        href="/admin/login"
        class="block w-full py-3 px-4 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors font-medium"
      >
        Admin Login
      </a>
      <p class="text-sm text-gray-500">
        Workers: use the link shared by your admin
      </p>
    </div>
  </div>
</div>
```

IMPORTANT:
- The (app) route group uses parentheses - SvelteKit treats this as a layout group, not a URL segment
- URLs remain clean: / not /(app)/
- Access key is immediately removed from URL after extraction to prevent leakage
  </action>
  <verify>
Directory structure:
- src/routes/(app)/+layout.svelte exists
- src/routes/(app)/+layout.ts exists
- src/routes/(app)/+page.svelte exists (with chore UI)
- src/routes/+page.svelte exists (with landing page)
`bun run build` completes without errors
  </verify>
  <done>Route structure reorganized with (app) group and access key validation</done>
</task>

<task type="auto">
  <name>Task 2: Update root layout for new routing</name>
  <files>src/routes/+layout.svelte</files>
  <action>
Update the root layout to work with the new route structure. The root layout should:
1. Keep Convex initialization
2. Keep PWA registration
3. Initialize auth state
4. NOT include chore-specific logic (that stays in (app) layout)

The key change is removing chore store initialization from root layout - that should only happen in the (app) layout where access is validated.

Update **src/routes/+layout.svelte**:

```svelte
<script lang="ts">
  /// <reference types="@vite-pwa/sveltekit" />
  import { onMount } from 'svelte';
  import { setupConvex, useConvexClient } from 'convex-svelte';
  import { PUBLIC_CONVEX_URL } from '$env/static/public';
  import { browser } from '$app/environment';
  import { pwaInfo } from 'virtual:pwa-info';
  import { setConvexClient } from '$lib/sync/engine.svelte';
  import { connectionStatus } from '$lib/sync/status.svelte';
  import { requestPersistentStorage } from '$lib/db/storage';
  import favicon from '$lib/assets/favicon.svg';

  let { children } = $props();

  let webManifestLink = $derived(pwaInfo ? pwaInfo.webManifest.linkTag : '');

  // Only initialize on client side
  if (browser) {
    setupConvex(PUBLIC_CONVEX_URL);
  }

  // Get Convex client at component init (must be called at top level, not in onMount)
  const convexClient = browser ? useConvexClient() : null;

  onMount(async () => {
    // Initialize connection status (must happen in browser)
    connectionStatus.init();

    // Request persistent storage for IndexedDB
    await requestPersistentStorage();

    // Share Convex client with sync engine (client was obtained at top level)
    if (convexClient) {
      setConvexClient(convexClient);
    }

    // Register service worker
    if (pwaInfo) {
      const { registerSW } = await import('virtual:pwa-register');
      registerSW({
        immediate: true,
        onRegistered(registration: ServiceWorkerRegistration | undefined) {
          console.log('[PWA] Service worker registered:', registration?.scope);
        },
        onRegisterError(error: Error) {
          console.error('[PWA] Service worker registration error:', error);
        }
      });
    }
  });
</script>

<svelte:head>
  {@html webManifestLink}
  <link rel="icon" href={favicon} />
</svelte:head>

{@render children?.()}
```

The chore store initialization and server subscription are removed from root layout - they will be added to the (app) layout in a moment.
  </action>
  <verify>
`bun run build` completes without errors
Root layout no longer references choreStore or api.chores
  </verify>
  <done>Root layout updated for new routing structure, chore logic moved to app layout</done>
</task>

<task type="auto">
  <name>Task 3: Add chore store initialization to (app) layout</name>
  <files>src/routes/(app)/+layout.svelte</files>
  <action>
Update the (app) layout to initialize the chore store and sync engine after access is validated. This moves the chore-specific initialization from the root layout.

Update **src/routes/(app)/+layout.svelte** to add chore initialization after access validation:

After the `onMount` validation succeeds (where `hasAccess = true`), add initialization:

```svelte
<script lang="ts">
  import { onMount } from 'svelte';
  import { goto } from '$app/navigation';
  import { page } from '$app/stores';
  import { browser } from '$app/environment';
  import { useQuery } from 'convex-svelte';
  import {
    getStoredAccessKey,
    storeAccessKey,
    clearAccessKey,
    validateAccessKey,
    getCachedValidation,
    extractKeyFromUrl
  } from '$lib/auth/access-key';
  import { adminAuth } from '$lib/auth/admin.svelte';
  import { connectionStatus } from '$lib/sync/status.svelte';
  import { choreStore } from '$lib/stores/chores.svelte';
  import { syncEngine } from '$lib/sync/engine.svelte';
  import { api } from '../../convex/_generated/api';

  let { children } = $props();

  let hasAccess = $state(false);
  let isValidating = $state(true);
  let error = $state<string | null>(null);
  let userName = $state<string | null>(null);
  let isInitialized = $state(false);

  // Server chores subscription (only active when hasAccess and online)
  const serverChores = browser ? useQuery(api.chores.list, {}) : null;

  // Hydrate from server when data arrives (only after access validated)
  $effect(() => {
    if (browser && hasAccess && serverChores?.data && connectionStatus.isOnline) {
      choreStore.hydrateFromServer(serverChores.data);
    }
  });

  async function initializeApp() {
    if (isInitialized) return;
    isInitialized = true;

    // Load local data first (instant)
    await choreStore.load();

    // Initialize sync engine (will process queue if online)
    await syncEngine.init();
  }

  onMount(async () => {
    // Check for key in URL first
    const urlKey = extractKeyFromUrl($page.url);
    if (urlKey) {
      // Clean URL immediately (remove ?key= from address bar)
      const cleanUrl = new URL($page.url);
      cleanUrl.searchParams.delete('key');
      window.history.replaceState({}, '', cleanUrl.toString());

      // Validate the URL key
      const result = await validateAccessKey(urlKey);
      if (result.valid) {
        storeAccessKey(urlKey);
        hasAccess = true;
        userName = result.displayName ?? null;
        isValidating = false;
        await initializeApp();
        return;
      } else {
        error = result.reason === 'revoked'
          ? 'This access key has been revoked. Please contact the admin for a new key.'
          : 'Invalid access key. Please check the link or contact the admin.';
        isValidating = false;
        return;
      }
    }

    // Check stored key
    const storedKey = getStoredAccessKey();
    if (storedKey) {
      // Try online validation first
      if (connectionStatus.isOnline) {
        const result = await validateAccessKey(storedKey);
        if (result.valid) {
          hasAccess = true;
          userName = result.displayName ?? null;
          isValidating = false;
          await initializeApp();
          return;
        } else {
          // Key was revoked or invalid
          clearAccessKey();
          error = result.reason === 'revoked'
            ? 'Your access key has been revoked. Please contact the admin for a new key.'
            : 'Your access key is no longer valid. Please request a new one.';
          isValidating = false;
          return;
        }
      } else {
        // Offline - use cached validation
        const cached = getCachedValidation();
        if (cached?.valid) {
          hasAccess = true;
          userName = cached.displayName ?? null;
          isValidating = false;
          await initializeApp();
          return;
        }
        // No valid cache, but we have a key - allow access (will revalidate online)
        hasAccess = true;
        isValidating = false;
        await initializeApp();
        return;
      }
    }

    // Check admin auth as fallback
    await adminAuth.checkAuth();
    if (adminAuth.isAuthenticated) {
      hasAccess = true;
      userName = 'Admin';
      isValidating = false;
      await initializeApp();
      return;
    }

    // No access - show error
    error = 'No access key found. Please use a link shared by the admin.';
    isValidating = false;
  });

  function handleRequestAccess() {
    alert('Please contact the farm administrator for an access key.');
  }
</script>

{#if isValidating}
  <div class="min-h-screen flex items-center justify-center bg-gray-50">
    <div class="text-center">
      <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto"></div>
      <p class="mt-4 text-gray-600">Checking access...</p>
    </div>
  </div>
{:else if hasAccess}
  {#if userName}
    <div class="fixed top-2 right-2 text-xs text-gray-500 bg-white/80 px-2 py-1 rounded shadow-sm z-50">
      {userName}
    </div>
  {/if}
  {@render children?.()}
{:else}
  <div class="min-h-screen flex items-center justify-center bg-gray-50 px-4">
    <div class="max-w-md w-full text-center">
      <div class="bg-white rounded-lg shadow-md p-8">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 mx-auto text-gray-400 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
        </svg>
        <h1 class="text-xl font-semibold text-gray-900 mb-2">Access Required</h1>
        <p class="text-gray-600 mb-6">
          {error ?? 'You need an access key to use this app.'}
        </p>
        <div class="space-y-3">
          <button
            onclick={handleRequestAccess}
            class="w-full py-2 px-4 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors"
          >
            Request Access
          </button>
          <a
            href="/admin/login"
            class="block w-full py-2 px-4 border border-gray-300 text-gray-700 rounded-md hover:bg-gray-50 transition-colors"
          >
            Admin Login
          </a>
        </div>
      </div>
    </div>
  </div>
{/if}
```

This ensures the chore store and sync engine only initialize after access is validated.
  </action>
  <verify>
`bun run build` completes without errors
(app) layout includes choreStore and syncEngine initialization
Chore data only loads after access validation
  </verify>
  <done>Chore store and sync engine initialization moved to (app) layout, gated by access validation</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete auth and access flow for Phase 3</what-built>
  <how-to-verify>
Test the full authentication and access key flow:

**1. Admin Sign Up (first user)**
- Navigate to http://localhost:5173/admin/login
- Toggle to "Sign Up" mode
- Create an account with email/password
- Verify you're redirected to /admin/keys
- First user should automatically be admin

**2. Create Access Key**
- On /admin/keys, enter a display name (e.g., "Test Phone")
- Click "Create Key"
- Verify shareable link appears
- Copy the link

**3. Test Worker Access**
- Open an incognito/private browser window
- Paste the access key URL
- Verify access is granted
- Verify ?key= is removed from URL bar after load
- Verify user name shows in corner

**4. Test Invalid Key**
- Try accessing with invalid key: http://localhost:5173/?key=invalidkey123
- Verify clear error message appears
- Verify option to request access or admin login is shown

**5. Test Key Revocation**
- In admin window, revoke the test key
- Refresh the worker window
- Verify access is now denied with "revoked" message

**6. Test Offline Access**
- With valid key in worker window, go offline (DevTools > Network > Offline)
- Refresh the page
- Verify cached validation allows continued access
  </how-to-verify>
  <resume-signal>Type "auth verified" if all flows work, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:
1. `bun run build` completes without errors
2. Route structure: /(app) for protected, /admin for admin-only
3. Access key validation with localStorage caching works
4. Admin authentication flow works
5. Offline access with cached validation works
</verification>

<success_criteria>
- Valid URL key grants immediate access
- URL is cleaned after key extraction (no ?key= in address bar)
- Invalid/revoked keys show clear error messages
- Cached validation enables offline access for 24 hours
- Admin can access app without access key
- Chore store only initializes after access is validated
- All Phase 3 success criteria from roadmap are met
</success_criteria>

<output>
After completion, create `.planning/phases/03-auth-and-access/03-04-SUMMARY.md`
</output>
